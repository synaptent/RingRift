# P18.2-1 – AI RNG and Seed Handling Map

This document maps RNG and seed-handling paths across the TypeScript backend + sandbox and the Python AI/rules/training stack. It classifies each RNG site by impact on gameplay parity and by current seeding quality, and surfaces priority refactor candidates for P18.2‑2 / P18.2‑3.

## 1. Terminology and Impact Classes

**Impact classes**:

- **P0** – Directly affects live gameplay move choice or rule outcomes.
- **P1** – Affects AI evaluation used in tests, contract vectors, or parity baselines.
- **P2** – Training- or experiment-only randomness.
- **P3** – Cosmetic / UX / logging only.

**Seeding quality**:

- **Good** – RNG is seeded from an explicit, traceable seed (game/session/experiment) and uses a dedicated PRNG instance.
- **Mixed** – Sometimes seeded explicitly; otherwise falls back to ambient randomness or derived seeds not tied to a game/session.
- **Poor** – Uses ambient randomness only (e.g. `Math.random`, `random.random`) or system time without a threadable seed.

## 2. Seed Origins and Global Flow

### 2.1 TypeScript game seeds

- Shared engine initialisation uses `rngSeed` on `GameState`:
  - `rngSeed` is created inside the shared engine by `createInitialGameState` when a new game is constructed.
  - The seed is generated by `generateGameSeed`, which currently calls `Math.random` directly (no external seed input).
- The database `Game` record has a nullable `rngSeed` column which can be set at game-creation time from HTTP input (`seed` field).
- On backend `GameSession` initialisation, the persisted DB `rngSeed` is **not** yet threaded into the `GameEngine` constructor; a fresh `rngSeed` is generated by the shared engine for that process.
- The AI service client derives an **effective seed** per AI move as:
  - `effectiveSeed = explicitSeedFromCaller ?? gameState.rngSeed`
  - This is sent to the Python AI service, which then seeds its own per-request RNG.

Implication: given a fixed `GameState.rngSeed`, backend and Python AI share the same game-level seed. However, DB-level `Game.rngSeed` and in-memory `GameState.rngSeed` can currently diverge, and the initial generation of `rngSeed` uses ambient randomness.

### 2.2 Python AI seeds

- The FastAPI `/ai/move` endpoint accepts:
  - `seed: Optional[int]` and `game_state.rng_seed: Optional[int]`.
  - It computes `effective_seed = request.seed or request.game_state.rng_seed`.
- When `effective_seed` is present, the endpoint constructs an `AIConfig` with `rng_seed=effective_seed` and _does not_ reuse a cached AI; this yields a per-request, per-game seeded RNG stream.
- When both `seed` and `game_state.rng_seed` are absent (test/utility contexts), the service reuses a cached AI instance whose `BaseAI` RNG seed is derived deterministically from `(difficulty, player_number)` but not from a game/session identifier.
- Training and evaluation code (self-play loops, dataset generation) accept an experiment-level `seed` in configuration and call helper functions (`seed_all`, `RingRiftEnv.reset(seed)`) that seed Python `random`, NumPy, and torch.

Implication: for production game traffic routed through the TS backend, the Python AI RNG is well-anchored on the `GameState.rngSeed` chosen in TS, but other contexts may rely on derived seeds.

## 3. TypeScript RNG and Seed Sites

This section lists significant RNG entry points on the TS side (backend, shared engine, sandbox), grouped by their role.

### 3.1 Shared RNG utilities

- `SeededRNG` – deterministic PRNG
  - Location: `src/shared/utils/rng.ts` (`SeededRNG` class).
  - Source: xorshift128+ with `splitmix32` seeding from a numeric `seed`.
  - Seed origin: passed in explicitly by callers; does not know about game/session IDs itself.
  - Usage scope:
    - Client sandbox engine uses `SeededRNG` as a per-sandbox-game RNG.
    - Backend AI components (GameSession + AIEngine) derive per-player `LocalAIRng` streams from `GameState.rngSeed` by mixing in the player number with a fixed constant (see `GameSession.createLocalAIRng` and `AIEngine.createDeterministicLocalRng`).
  - Impact: **P0** when used to pick sandbox AI moves (local gameplay), **P2** in any test helpers.
  - Seeding quality: **Good** at the class level (pure seeded PRNG), but callers may choose poor seeds.

- `generateGameSeed` – game seed factory
  - Location: `src/shared/utils/rng.ts` (`generateGameSeed`).
  - Source: `Math.random()` scaled to a 31-bit positive integer.
  - Seed origin: ambient JS RNG; not tied to a game/session identifier or external configuration.
  - Usage scope:
    - Called by `createInitialGameState` when no `rngSeed` argument is supplied.
    - Used by the client sandbox engine to seed local `SeededRNG` instances and `GameState.rngSeed` for sandbox games.
  - Impact: **P0** (root of per-game RNG when none is provided explicitly; drives backend ↔ Python AI parity and sandbox AI).
  - Seeding quality: **Poor** (ambient randomness only; not reproducible without persisting the resulting `rngSeed`).

**Reproducibility contract (TS side):**

- For any given `GameState.rngSeed` and game configuration:
  - Backend `GameSession` and `AIEngine` must derive **deterministic per-player RNG streams** solely from `(rngSeed, playerNumber)` using the documented mixing strategy.
  - Sandbox AI must treat `GameState.rngSeed` as the single canonical seed for its own `SeededRNG` instance per game.
  - Python AI requests sent via `AIServiceClient` must include `seed: effectiveSeed`, where `effectiveSeed` is either an explicit caller seed or `gameState.rngSeed`, so that backend ↔ Python parity tools can reproduce move sequences.
- The `SeededRNG` algorithm and `splitmix32` seeding are treated as **stable** for parity and replay; changes require:
  - Updating this document,
  - Bumping any format/version identifiers on RNG-dependent trace/contract fixtures,
  - Regenerating affected contract vectors and plateau snapshots as part of a coordinated migration.

### 3.2 Shared engine game-state initialisation

- `createInitialGameState`
  - Location: `src/shared/engine/initialState.ts`.
  - RNG usage:
    - Writes `rngSeed: rngSeed ?? generateGameSeed()` into the returned `GameState`.
    - Also sets timestamps `createdAt` and `lastMoveAt` using `new Date()` (UX/metadata only).
  - Seed origin: caller-supplied `rngSeed` when provided; otherwise `generateGameSeed` as above.
  - Impact: **P0** – this is the canonical source of `GameState.rngSeed` for any host that uses the shared engine for game creation.
  - Seeding quality: **Mixed** – good when callers thread through an explicit seed (e.g. from DB or HTTP); poor when falling back to `generateGameSeed`.

### 3.3 Backend game host and orchestrator

- `GameSession.initialize`
  - Location: `src/server/game/GameSession.ts`.
  - RNG usage: none directly; creates a `GameEngine` instance and replays historical moves.
  - Seed handling:
    - Reads the persisted `game.rngSeed` from the database and, when present, passes it into the `GameEngine` constructor:
      - `new GameEngine(gameId, boardType, players, timeControl, isRated, interactionManager, rngSeed, rulesOptions)`.
    - When the DB seed is `null`/`undefined`, the shared engine falls back to `generateGameSeed` on first state creation.
  - Impact: **P0/P1** – determines which `rngSeed` the backend will send to the Python AI service via `GameState.rngSeed`, affecting cross-host parity and replayability.
  - Seeding quality: **Good/Mixed** – when `Game.rngSeed` is set, the backend honours it as the canonical seed; when it is absent, ambient `Math.random` is still used once to generate a fresh game seed.

- `GameSession.maybePerformAITurn`
  - Location: `src/server/game/GameSession.ts`.
  - RNG usage: constructs a deterministic `LocalAIRng` per AI player/turn and passes it to local selection paths; uses deterministic order when auto-resolving decision-phase timeouts (always picks the first candidate).
  - Seed handling:
    - Fetches the current `GameState` from `GameEngine`, which includes `rngSeed` populated by the shared engine (anchored on `Game.rngSeed` when present).
    - Derives a per-player `LocalAIRng` via `createLocalAIRng(state, playerNumber)`, which seeds a `SeededRNG` from `gameState.rngSeed` and the player number.
    - For decision phases (`line_processing`, `territory_processing`), passes this RNG directly into `globalAIEngine.chooseLocalMoveFromCandidates(...)`.
    - For service-backed moves, calls `globalAIEngine.getAIMove(playerNumber, state)` without an explicit RNG; `AIEngine` itself now derives a deterministic `LocalAIRng` from `gameState.rngSeed` for all local paths.
  - Impact: **P0** – orchestrates live AI turns in backend games, including service-backed, local-fallback, and pure local (mode: 'local') configurations.
  - Seeding quality: **Good** – service-backed moves are seeded via `GameState.rngSeed` into Python, and all local/heuristic/random fallbacks use `SeededRNG` derived from the same `rngSeed` instead of ambient `Math.random`.

- `TurnEngineAdapter`
  - Location: `src/server/game/turn/TurnEngineAdapter.ts`.
  - RNG usage: none; decision handling for AI players uses a deterministic policy (always picks the first option).
  - Impact: **P0** – directly affects rule outcomes when the orchestrator is the authoritative engine.
  - Seeding quality: **Good** – no randomness; behaviour is fully deterministic given the input `GameState` and `Move`.

### 3.4 Backend AI engine and AI service client

- `AIEngine.getAIMove`
  - Location: `src/server/game/ai/AIEngine.ts`.
  - RNG usage:
    - Level 1 (Python service): no RNG locally; calls the Python AI service and validates its move.
    - Level 2 (local heuristic fallback): calls `selectLocalHeuristicMove(gameState, validMoves, effectiveRng)`.
    - Level 3 (last-resort random): selects a move via `effectiveRng` over the remaining candidate set.
  - Seed handling:
    - Service-backed path:
      - Uses `AIServiceClient.getAIMove(gameState, playerNumber, difficulty, aiType, /* seed */ undefined, options)`.
      - The AI service client derives `effectiveSeed = seed ?? gameState.rngSeed` and includes it in the HTTP request; Python `BaseAI` then seeds a dedicated `random.Random` instance with this value.
    - Local heuristic and random-fallback paths:
      - Use an optional `rng: LocalAIRng` hook when provided (tests / parity harnesses and `GameSession` can supply a seeded RNG).
      - When no RNG is supplied, derive a deterministic `LocalAIRng` from `gameState.rngSeed` and `playerNumber` via `SeededRNG`, rather than `Math.random`.
  - Impact: **P0** – determines live AI move choices whenever local fallback is engaged (service degraded, validation failure, or explicit `mode: 'local'`).
  - Seeding quality:
    - Service-backed path: **Good** (seeded by `GameState.rngSeed` and passed through to Python).
    - Local heuristic / random fallback: **Good** – deterministic by default via `SeededRNG`, and overrideable by explicitly injected RNGs in tests and harnesses.

- `AIEngine.getLocalFallbackMove` / `AIEngine.chooseLocalMoveFromCandidates`
  - Location: `src/server/game/ai/AIEngine.ts`.
  - RNG usage: delegates to the shared engine’s `chooseLocalMoveFromCandidates` with a `LocalAIRng` derived from `gameState.rngSeed` and `playerNumber` when no RNG is supplied.
  - Impact: **P0** – used after AI service failures or move rejections to keep games progressing.
  - Seeding quality: **Good** – deterministic for a fixed `rngSeed` and player number, while still accepting explicit RNGs from tests/parity harnesses.

- `AIServiceClient.getAIMove`
  - Location: `src/server/services/AIServiceClient.ts`.
  - RNG usage: none directly; measures latency and manages concurrency/circuit breaking.
  - Seed handling:
    - Computes `effectiveSeed = seed ?? gameState.rngSeed` before constructing the `MoveRequest` payload.
    - Includes `seed: effectiveSeed` in the request when non-`undefined`.
  - Impact: **P0/P1** – mediates all backend → Python AI move requests for live games and parity tests.
  - Seeding quality: **Good** – faithfully threads `GameState.rngSeed` through to the Python AI, provided `GameState.rngSeed` itself is well chosen.

### 3.5 Client sandbox engine and local AI

- `ClientSandboxEngine` constructor and RNG field
  - Location: `src/client/sandbox/ClientSandboxEngine.ts`.
  - RNG usage:
    - Creates a per-sandbox-game seed via `generateGameSeed()`.
    - Stores this as both:
      - `this.rng = new SeededRNG(gameSeed)`.
      - `gameState.rngSeed = gameSeed`.
    - This RNG is later exposed to the sandbox AI as a `LocalAIRng` via:
      - `const effectiveRng = rng ?? (() => this.rng.next());` in `maybeRunAITurn`.
  - Seed origin: ambient `Math.random` via `generateGameSeed`.
  - Impact: **P0** – drives all local sandbox AI behaviour (placement, movement, capture chain choices, skip decisions, etc.).
  - Seeding quality: **Mixed** – once initialised, sandbox AI is deterministic for that session, but the seed has no external control surface and is not aligned with backend/DB `rngSeed` by default.

- `ClientSandboxEngine.maybeRunAITurn` → `maybeRunAITurnSandbox`
  - Locations:
    - `src/client/sandbox/ClientSandboxEngine.ts` (`maybeRunAITurn`).
    - `src/client/sandbox/sandboxAI.ts` (`maybeRunAITurnSandbox`).
  - RNG usage:
    - `maybeRunAITurn` passes a `LocalAIRng` that wraps `SeededRNG.next()` unless a test supplies a custom RNG.
    - `maybeRunAITurnSandbox` in turn passes this RNG down to shared helpers such as `chooseLocalMoveFromCandidates` and uses it for all stochastic decisions (e.g., choosing among placement/movement candidates).
    - Some diagnostic logging / stall detection uses timestamps and hashes but no additional randomness.
  - Impact: **P0** – full control over local sandbox AI turn behaviour.
  - Seeding quality: **Good** at the function level (it always uses a PRNG instance), but since the underlying seed comes from ambient `Math.random` and is not coordinated with backend seeds, sandbox ↔ backend parity is currently ad-hoc.

### 3.6 Summary of TS RNG sites

| Location                                                | Usage                              | Seed source                                                                      | Impact | Seeding quality | Notes                                                                            |
| ------------------------------------------------------- | ---------------------------------- | -------------------------------------------------------------------------------- | ------ | --------------- | -------------------------------------------------------------------------------- |
| Shared `SeededRNG`                                      | General-purpose PRNG               | Caller-provided numeric seed                                                     | P0/P2  | Good            | Used primarily in client sandbox; safe building block.                           |
| `generateGameSeed`                                      | Root game seeds when none provided | `Math.random`                                                                    | P0     | Poor            | No deterministic control; DB `Game.rngSeed` not always used.                     |
| `createInitialGameState`                                | Sets `GameState.rngSeed`           | Explicit arg or `generateGameSeed`                                               | P0     | Mixed           | Deterministic when host threads in a seed; otherwise ambient.                    |
| `GameSession.maybePerformAITurn` → `AIEngine.getAIMove` | Backend AI turns                   | `GameState.rngSeed` (TS) → Python `rng_seed` plus TS `SeededRNG` for local paths | P0     | Good            | Service and local fallback now share a seeded RNG rooted in `GameState.rngSeed`. |
| `AIServiceClient.getAIMove`                             | Backend → Python AI move requests  | `seed ?? gameState.rngSeed`                                                      | P0/P1  | Good            | Correctly threads the engine seed into the AI service.                           |
| `ClientSandboxEngine` + `maybeRunAITurnSandbox`         | Local sandbox AI                   | Per-sandbox `SeededRNG` seeded by `generateGameSeed`                             | P0     | Mixed           | Deterministic per session but not aligned with backend seeds by default.         |

## 4. Python RNG and Seed Sites (Summary)

Python-side analysis focuses on modules that participate in live move choice, parity tests, or training determinism. Rules core and the game engine are intentionally pure/deterministic and contain **no RNG**.

### 4.1 Rules engine and game engine

- `app/rules/core.py` and `app/rules/mutable_state.py`
  - RNG usage: none. Functions operate deterministically on `GameState` and board structures.
  - Impact: **P0** – all rule outcomes and invariants depend on these modules.
  - Seeding quality: **Good** (no randomness).

- `app/game_engine.py`
  - RNG usage: none in move generation or rule evaluation.
  - Non-determinism is limited to timestamps and debug snapshot filenames used during invariant failures.
  - Impact:
    - Rules behaviour: **P0** and deterministic.
    - Snapshot metadata: **P3**.
  - Seeding quality: **Good** (no RNG in rules path).

### 4.2 Online AI – `BaseAI` and concrete AIs

- `BaseAI`
  - Provides a per-instance RNG: `self.rng: random.Random`.
  - Seed selection:
    - If `config.rng_seed` is not `None`, uses that exact seed.
    - Otherwise, derives `seed = (difficulty * 1_000_003) ^ (player_number * 97_911)` and masks to 32 bits.
  - RNG usage:
    - `should_pick_random_move` draws Bernoulli(`randomness`).
    - `get_random_element` and `shuffle_array` wrap `self.rng`.
  - Impact:
    - Move randomness: **P0** when concrete AIs call `get_random_element` / `should_pick_random_move`.
    - Think-time jitter: **N/A** – artificial "thinking time" delays have been removed; any per-move latency now comes solely from search/evaluation cost and network hops.
  - Seeding quality: **Good** when `rng_seed` is provided; **Mixed** overall because some non-production contexts rely on the derived `(difficulty, player)` seed.

- `HeuristicAI`, `MctsAI`, `DescentAI`, `RandomAI`
  - All inherit from `BaseAI` and use `self.rng` exclusively for stochastic choices:
    - `HeuristicAI` uses randomness for occasional random moves and fallback selection when no clear best move exists.
    - `MctsAI` uses RNG in tree expansion and rollout policies via `self.get_random_element` and `self.rng.choices`.
    - `DescentAI` uses RNG primarily for exploration and rare random-move fallbacks; training-time Descent instances are created with `rngSeed=config.seed`.
    - `RandomAI` uses RNG for every move and for small evaluation noise.
  - Impact: **P0** – directly determine live move choices when these AIs are used.
  - Seeding quality: **Good** when called from `/ai/move` with a proper `rng_seed` (the normal backend path).

### 4.3 FastAPI AI service entrypoint

- `/ai/move` endpoint
  - Computes `effective_seed = request.seed or request.game_state.rng_seed`.
  - When `effective_seed` is present:
    - Builds `AIConfig(..., rng_seed=effective_seed, ...)` and constructs a fresh AI instance for this request.
    - All RNG within that instance (and thus all move randomness) is tied to this seed.
  - When `effective_seed` is absent:
    - Reuses a cached AI instance initialised without `rng_seed`; `BaseAI` then falls back to the `(difficulty, player_number)`-derived seed.
  - Impact: **P0** – live gameplay move RNG for all backend games.
  - Seeding quality: **Good** for the normal backend path (since `AIServiceClient` always supplies a seed when `GameState.rngSeed` is defined); **Mixed** for ad-hoc/testing paths that omit seeds.

- `/ai/evaluate` and `/ai/choice/*` endpoints
  - `evaluate` uses deterministic heuristics / models and does not invoke `self.rng`.
  - The choice endpoints (`line_reward_option`, `ring_elimination`, `region_order`, `line_order`, `capture_direction`) implement fixed, deterministic selection policies mirroring TS heuristics and use no RNG.
  - Impact: **P1** – used by tests and parity scenarios; deterministic by construction.
  - Seeding quality: **Good** (no RNG).

### 4.4 Training and evaluation

- `training/env.RingRiftEnv.reset(seed)`
  - When `seed` is provided, calls `random.seed(seed)`, `np.random.seed(seed)`, and `torch.manual_seed(seed)`.
  - Creates initial game states deterministically via a shared helper.
  - Impact: **P2** – training and evaluation self-play episodes.
  - Seeding quality: **Good** – all major RNG sources are seeded in one place.

- `training/train.seed_all(seed)` and `distributed.seed_everything`
  - Apply global seeding for Python `random`, NumPy, torch, and cuDNN determinism flags.
  - Used by main training loops and some evaluation scripts.
  - Impact: **P2** – training, model evaluation, and experiments.
  - Seeding quality: **Good** – experiment-level determinism for a fixed `seed`.

- Dataset and augmentation RNG
  - Dataset code (e.g., hex board augmentation) uses `random.randint` and NumPy RNG for augmentation decisions and synthetic data generation.
  - These functions rely on the global seeds set by `seed_all` / `RingRiftEnv.reset`.
  - Impact: **P2** – affects training but not live gameplay.
  - Seeding quality: **Good** – reproducible per experiment seed.

### 4.5 Summary of Python RNG sites

| Location                                                        | Usage                                               | Seed source                                           | Impact | Seeding quality | Notes                                                                                           |
| --------------------------------------------------------------- | --------------------------------------------------- | ----------------------------------------------------- | ------ | --------------- | ----------------------------------------------------------------------------------------------- |
| `BaseAI` RNG                                                    | Core AI move randomness and think-time jitter       | `AIConfig.rng_seed` or derived `(difficulty, player)` | P0     | Good/Mixed      | Good for `/ai/move` calls with explicit seed; derived seeds used only when no seed is supplied. |
| Concrete AIs (`HeuristicAI`, `MctsAI`, `DescentAI`, `RandomAI`) | Use `BaseAI.rng` for move selection and exploration | Same as `BaseAI`                                      | P0     | Good            | Deterministic for fixed `rng_seed`.                                                             |
| `/ai/move` endpoint                                             | Seeds AIs per request                               | `request.seed` or `game_state.rng_seed`               | P0     | Good/Mixed      | Production path is well seeded; non-seeded contexts fall back to derived seeds.                 |
| `RingRiftEnv.reset`, `seed_all`                                 | Training & evaluation seeding                       | Experiment `seed`                                     | P2     | Good            | Centralised training determinism.                                                               |
| Rules core + game engine                                        | No RNG                                              | N/A                                                   | P0/P1  | Good            | Deterministic rules; RNG only in AI/training layers.                                            |

## 5. High-Priority Refactor Pointers (Inputs to P18.2‑2 / P18.2‑3)

The following sites are the most impactful P0/P1 targets for refactoring toward explicit, parity-friendly RNG threading:

1. **Backend game seed honouring (TS)**
   - Problem: `GameSession.initialize` currently passes `undefined` for the `rngSeed` argument when constructing `GameEngine`, ignoring the persisted `Game.rngSeed` and any HTTP `seed` that may have been supplied at game creation.
   - Impact: repeated backend sessions for the same logical game can end up with different `GameState.rngSeed` values, even though the DB row has a stable `rngSeed`. This weakens the intended “seed as SSOT” contract and can complicate cross-host replay/parity tooling.
   - Refactor direction: thread `Game.rngSeed` into the `GameEngine` constructor (and ultimately into `createInitialGameState`) for newly created games, and ensure any resumed sessions reconstruct the same `rngSeed` the AI service sees.

2. **Local fallback AI RNG on the backend (TS)**
   - Problem: `AIEngine` uses `Math.random` for its local heuristic and last-resort random fallbacks whenever no `LocalAIRng` is supplied. In production, callers do not supply a seeded RNG, so service-degraded paths can diverge between runs even with the same `GameState.rngSeed`.
   - Impact: when the Python service is unavailable or returns invalid moves, fallback moves can introduce non-deterministic divergence in P0 gameplay and in parity traces, undermining the seed contract precisely when the system is already degraded.
   - Refactor direction: derive a `LocalAIRng` from `GameState.rngSeed` (or another per-game PRNG stream) and thread it through all local-selection code paths (`getAIMove`, `getLocalAIMove`, `chooseLocalMoveFromCandidates`, and the final random choice) so that fallback behaviour is deterministic for a given game seed.

3. **Sandbox seed alignment and external control (TS)**
   - Problem: the client `ClientSandboxEngine` seeds its `SeededRNG` (and `GameState.rngSeed`) via `generateGameSeed`, which itself uses ambient `Math.random`. There is no public interface to inject a known seed or to align sandbox seeds with backend `Game.rngSeed` or with parity test fixtures.
   - Impact: local sandbox AI behaves deterministically _within a session_, but reproducing a particular RNG trajectory (e.g., from a production trace or a parity fixture) requires manual capture of the sandbox seed. Sandbox vs backend parity harnesses cannot easily share RNG streams.
   - Refactor direction: allow sandbox callers to specify a seed (e.g., via URL parameter, dev control, or trace payload), thread that seed into `ClientSandboxEngine`, and consider aligning sandbox seed semantics with backend `GameState.rngSeed` / DB `Game.rngSeed`.

4. **Root seed factory semantics (`generateGameSeed`) (TS)**
   - Problem: `generateGameSeed` currently delegates to `Math.random`, which is process-global and not itself seedable in Node/JS without additional libraries. This makes initial seeds non-reproducible by default and couples game seeds to ambient runtime randomness.
   - Impact: by itself this is acceptable when the resulting `rngSeed` is persisted and treated as the SSOT; however, in combination with the current host initialisation (which sometimes regenerates seeds instead of using persisted ones), it weakens overall determinism.
   - Refactor direction: keep `generateGameSeed` as the _only_ place ambient randomness may appear, but tighten its contract and call-sites so that:
     - New games persist its output into `Game.rngSeed` immediately.
     - All hosts (backend, sandbox, and AI service) treat that persisted seed as the canonical per-game RNG root rather than re-generating fresh seeds.

5. **Unseeded paths into Python AI (edge/test contexts)**
   - Problem: the FastAPI `/ai/move` endpoint supports calls without `seed` or `game_state.rng_seed`, in which case `BaseAI` falls back to a per-(difficulty, player) derived seed. While this is deterministic, it is not tied to a particular game or trace.
   - Impact: parity and determinism expectations are clear for production traffic (where `AIServiceClient` always provides a seed when `GameState.rngSeed` is set), but ad-hoc/testing contexts that omit seeds may not behave as engineers expect when trying to reproduce a given game state.
   - Refactor direction: for parity-sensitive tests and tools, require an explicit seed (or `game_state.rng_seed`) and treat missing seeds as a contract error, or at least log and surface them clearly so they are not mistaken for fully seed-threaded scenarios.

## 6. Relationship to PASS18 Findings

- This map confirms that rules logic in both TS and Python remains deterministic and RNG-free, matching PASS18’s expectation that all non-determinism lives in AI and host layers.
- The primary parity risks identified in PASS18 (sandbox vs backend vs Python AI) are concentrated in:
  - Inconsistent honouring of `rngSeed` between DB and backend `GameEngine`.
  - Unseeded TS local fallback AI paths in `AIEngine`.
  - Sandbox AI seeds not explicitly aligned with backend or test harness seeds.
- Training and evaluation RNG are already well-structured around explicit experiment seeds, so P18.2‑2 / P18.2‑3 can focus on tightening host and online-AI seeding rather than redesigning training RNG.

This document is the single source of truth (SSoT) for RNG and seed-handling as of P18.2‑1 and should be referenced by subsequent parity and determinism remediation tasks.
