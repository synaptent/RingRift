# P18.1-1 Capture & Territory Host Path Diagnostic Map

> **Date:** 2025-11-30
> **Status:** Diagnostic SSoT for P18.1 and P18.2 remediation.
> **Scope:** `GameEngine.ts`, `GameSession.ts`, `ClientSandboxEngine.ts` and related failing tests.

## 1. Host Codepath Inventory

### A. Backend Host: [`GameEngine.ts`](../../../src/server/game/GameEngine.ts)

The backend engine is in a hybrid state, supporting both a legacy automatic pipeline and a new move-driven decision pipeline (enabled via `useMoveDrivenDecisionPhases`).

**Capture Entry Points:**

- **`makeMove` (`overtaking_capture`, `continue_capture_segment`)**:
  - **Logic**: Delegates mutation to shared [`applyCaptureAggregate`](../../../src/shared/engine/aggregates/CaptureAggregate.ts).
  - **Chaining**: Updates local `chainCaptureState` using shared [`getChainCaptureContinuationInfo`](../../../src/shared/engine/aggregates/CaptureAggregate.ts).
  - **Enforcement**: Checks `chainCaptureState` to enforce mandatory continuation (same player, same stack).
- **`getValidMoves`**:
  - **Logic**: If `chainCaptureState` is active, delegates to shared [`getChainCaptureContinuationInfo`](../../../src/shared/engine/aggregates/CaptureAggregate.ts) to enumerate `continue_capture_segment` moves.
  - **Legacy**: If no chain, delegates to `RuleEngine.getValidMoves` (which uses shared `enumerateAllCaptureMovesAggregate`).

**Territory Entry Points:**

- **`makeMove` (`process_territory_region`)**:
  - **Move-Driven**: Calls shared [`applyProcessTerritoryRegionDecision`](../../../src/shared/engine/territoryProcessing.ts). Sets `pendingTerritorySelfElimination`.
  - **Legacy**: Calls local `processOneDisconnectedRegion`, which wraps shared `applyTerritoryRegion` but handles self-elimination via `eliminatePlayerRingOrCapWithChoice` (internal method).
- **`makeMove` (`eliminate_rings_from_stack`)**:
  - **Logic**: Calls shared [`applyEliminateRingsFromStackDecision`](../../../src/shared/engine/territoryDecisionHelpers.ts). Clears `pendingTerritorySelfElimination`.
- **`stepAutomaticPhasesForTesting`**:
  - **Legacy**: Manually drives the loop of `getValidMoves` -> `applyDecisionMove` for automatic phases when move-driven mode is off.

**Divergence Risk**: The legacy `processOneDisconnectedRegion` path in `GameEngine` manually orchestrates the "region collapse -> self elimination" sequence, whereas the move-driven path relies on the client/AI to submit the second move.

### B. Session Orchestration: [`GameSession.ts`](../../../src/server/game/GameSession.ts)

`GameSession` manages the real-time lifecycle and maps abstract game phases to timeouts and auto-resolution.

**Entry Points:**

- **`scheduleDecisionPhaseTimeout`**:
  - Maps `chain_capture` and `territory_processing` phases to timeouts.
- **`classifyDecisionSurface`**:
  - Maps `continue_capture_segment` moves to `capture_direction` choice kind.
  - Maps `process_territory_region` moves to `region_order` choice kind.
  - Maps `eliminate_rings_from_stack` moves to `ring_elimination` choice kind.
- **`handleDecisionPhaseTimedOut`**:
  - Auto-selects a move when timeout occurs.

**Observation**: `GameSession` is largely agnostic to the _logic_ of capture/territory, relying on `GameEngine` to expose the correct moves.

### C. Client Sandbox: [`ClientSandboxEngine.ts`](../../../src/client/sandbox/ClientSandboxEngine.ts)

The sandbox engine mirrors the backend but often implements its own control loops for automatic processing.

**Capture Entry Points:**

- **`applyCanonicalMoveInternal` (`overtaking_capture`, `continue_capture_segment`)**:
  - **Logic**: Calls local `applyCaptureSegment` which wraps shared [`applyCaptureSegmentAggregate`](../../../src/shared/engine/aggregates/CaptureAggregate.ts).
  - **Chaining**: Calls shared [`getChainCaptureContinuationInfoAggregate`](../../../src/shared/engine/aggregates/CaptureAggregate.ts) to detect if chain must continue.
- **`performCaptureChainInternal`**:
  - **Logic**: A local recursive loop that auto-plays capture chains for human clicks. This is a **complex local implementation** that risks diverging from the step-by-step backend enforcement.
- **`enumerateCaptureSegmentsFrom`**:
  - **Logic**: Delegates to `enumerateCaptureSegmentsFromBoard` (from `sandboxCaptures.ts`), which is a wrapper around shared logic but uses local adapters.

**Territory Entry Points:**

- **`processDisconnectedRegionsForCurrentPlayer`**:
  - **Logic**: A complex local loop that finds disconnected regions (using shared `findDisconnectedRegionsOnBoard`) and processes them.
  - **Move-Driven**: Uses shared [`applyProcessTerritoryRegionDecision`](../../../src/shared/engine/territoryProcessing.ts).
  - **Legacy**: Has a fallback path using `processOneDisconnectedRegion` (local).
  - **Self-Elimination**: Has logic to auto-select self-elimination targets in some modes.

**Divergence Risk**: `performCaptureChainInternal` and `processDisconnectedRegionsForCurrentPlayer` are heavy local orchestrators that duplicate the state-machine logic of `GameEngine`.

---

## 2. Red / Flaky Test Cluster Mapping

| Suite                                                                                                                                  |    Status    | Divergence / Issue                                                                                             | Host/Shared Path                                                                                 |
| :------------------------------------------------------------------------------------------------------------------------------------- | :----------: | :------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------- |
| [`captureSequenceEnumeration.test.ts`](../../../tests/unit/captureSequenceEnumeration.test.ts)                                         |   **FAIL**   | Historical failure noted in 2025-11: sandbox vs backend capture enumeration mismatched; verify current status. | `enumerateSequencesSandbox` (sandboxCaptures) vs `enumerateSequencesBackend` (CaptureAggregate). |
| [`GameEngine.chainCaptureChoiceIntegration.test.ts`](../../../tests/unit/GameEngine.chainCaptureChoiceIntegration.test.ts)             |   **FAIL**   | Historical failure noted in 2025-11: helper DFS enumerated different chains than `GameEngine` produced.        | `GameEngine.getValidMoves` (chain_capture phase) vs local test DFS.                              |
| [`BoardManager.territoryDisconnection.test.ts`](../../../tests/unit/BoardManager.territoryDisconnection.test.ts)                       | **REPLACED** | Legacy `GameEngine.territoryDisconnection.test.ts` removed; territory disconnection coverage moved here.       | `BoardManager.findDisconnectedRegions` / shared territory helpers.                               |
| [`ClientSandboxEngine.branchCoverage4.test.ts`](../../../tests/unit/ClientSandboxEngine.branchCoverage4.test.ts)                       | **REPLACED** | `applyCanonicalProcessTerritoryRegion` is private; coverage now lives in branch-coverage suites.               | `ClientSandboxEngine.applyCanonicalProcessTerritoryRegion` (via test harness).                   |
| [`ClientSandboxEngine.territoryDisconnection.hex.test.ts`](../../../tests/unit/ClientSandboxEngine.territoryDisconnection.hex.test.ts) |   **PASS**   | N/A (Green but covers risky hex territory logic).                                                              | `ClientSandboxEngine.processDisconnectedRegionsForCurrentPlayer`.                                |

---

## 3. Host vs Shared-Engine Usage Analysis

### Capture

- **Good Usage**:
  - `GameEngine` and `ClientSandboxEngine` both use `applyCaptureAggregate` / `applyCaptureSegmentAggregate` for the atomic mutation.
  - Both use `getChainCaptureContinuationInfo` to check for continuation.
- **Divergent / Legacy**:
  - **Enumeration**: `captureSequenceEnumeration.test.ts` failure proves that `sandboxCaptures.ts` (used by sandbox) and `CaptureAggregate.ts` (used by backend) produce different results. This is the **primary root cause** of capture parity issues.
  - **Chain Execution**: `ClientSandboxEngine.performCaptureChainInternal` is a custom recursive loop that might not match `GameEngine`'s step-by-step `chain_capture` phase enforcement exactly.

### Territory

- **Good Usage**:
  - Both engines use `applyProcessTerritoryRegionDecision` and `applyEliminateRingsFromStackDecision` in their "move-driven" paths.
  - Both use shared `findDisconnectedRegions` (via wrappers).
- **Divergent / Legacy**:
  - **Legacy Fallbacks**: Both engines retain complex "legacy" paths (`processOneDisconnectedRegion` in backend, manual loop in sandbox) that are still exercised by tests and potentially by the application if flags are off.
  - **Test Harness**: The failing `GameEngine.territoryDisconnection.test.ts` relies on the legacy automatic processing pipeline (`stepAutomaticPhasesForTesting`), which seems to be broken or drifting from the shared implementation.

---

## 4. Recommendations for Remediation

1.  **Unify Capture Enumeration (P18.1)**:
    - Refactor `ClientSandboxEngine` (and `sandboxCaptures.ts`) to use `enumerateAllCaptureMovesAggregate` directly, removing the divergent local implementation.
    - Ensure `CaptureBoardAdapters` in the shared engine can fully support the sandbox's `BoardState` (which it seems to, but the test failure implies a logic difference).

2.  **Standardise Territory Processing (P18.2)**:
    - Fix the legacy `processOneDisconnectedRegion` in `GameEngine` to correctly delegate to the shared `applyTerritoryRegion` helper, or migrate the failing tests to use the move-driven pipeline.
    - Expose `applyCanonicalProcessTerritoryRegion` in `ClientSandboxEngine` for testing (fix the `TypeError`).

3.  **Align Chain Execution**:
    - Verify that `ClientSandboxEngine.performCaptureChainInternal` strictly follows the `getChainCaptureContinuationInfo` logic at every step, or replace it with a loop that just calls `applyCanonicalMove` repeatedly.

4.  **Add Backend–Sandbox Advanced-Phase Parity Harness (P18.1-4)**:
    - Add and maintain a focused Jest backend–sandbox parity suite under `tests/unit/Backend_vs_Sandbox.CaptureAndTerritoryParity.test.ts` that drives identical capture chains, territory disconnection (including Q23-style self-elimination), and combined line+territory scenarios through both `GameEngine` and `ClientSandboxEngine`. This suite should assert equality of legal move surfaces, successor states, and shared S/T metrics across hosts, and serve as a regression guard for capture and territory host-path fixes made in P18.1 and P18.2.
