# P18.3-1 – Decision Lifecycle and Timeout Semantics Spec

Status: Draft v1 (P18.3-1)
Owner: PASS18 – Decision Lifecycle & Host Semantics
Scope: TS backend host, WebSocket server, and orchestrator-backed decision phases.

This document is the single source of truth (SSoT) for how the RingRift TS host manages decision phases, timeouts, reconnect windows, and resign/leave semantics.

It is implementation-aligned with:

- [`GameSession`](src/server/game/GameSession.ts:76)
- [`GameEngine`](src/server/game/GameEngine.ts:110)
- [`WebSocketServer`](src/server/websocket/server.ts:117)
- [`WebSocketInteractionHandler`](src/server/game/WebSocketInteractionHandler.ts:32)
- [`routes/game.ts`](src/server/routes/game.ts:1)
- [`choice` state machine](src/shared/stateMachines/choice.ts:1)
- [`connection` state machine](src/shared/stateMachines/connection.ts:9)
- [`GameContext`](src/client/contexts/GameContext.tsx:113)
- Invariants in [`INVARIANTS_AND_PARITY_FRAMEWORK.md`](docs/INVARIANTS_AND_PARITY_FRAMEWORK.md:1)

## 1. Overview and goals

The decision lifecycle defines how the host behaves when a human player must choose among multiple canonical decisions (line, territory, chain capture, resignation) and what happens under timeout, disconnect, or explicit resign/leave.

The lifecycle must guarantee:

- No violation of `INV-ACTIVE-NO-MOVES`: an `active` game must never expose a state where the current player has no legal global action (placement, movement, capture, or required decision). The safety net in [`GameEngine.getValidMoves()`](src/server/game/GameEngine.ts:3408) and [`GameEngine.resolveBlockedStateForCurrentPlayerForTesting()`](src/server/game/GameEngine.ts:4098) remains authoritative.
- No violation of `INV-PHASE-CONSISTENCY`: completed games must not be left in bookkeeping or decision phases. [`GameEngine.endGame()`](src/server/game/GameEngine.ts:3278) normalises `currentPhase` to `ring_placement`.
- Compliance with `INV-TERMINATION`: long-term idle or disconnected games must converge to a terminal result (`completed` or `abandoned`) rather than remaining indefinitely `active`.
- Clear, predictable behaviour under decision-phase timeout, move-clock timeout, disconnect, and explicit resign/leave, for both rated and unrated games.
- Compatibility with orchestrator-first hosting: decision phases are expressed as canonical `Move` instances via [`GameEngine.getValidMoves()`](src/server/game/GameEngine.ts:3408) and processed through [`GameEngine.makeMove()`](src/server/game/GameEngine.ts:1255) / [`GameEngine.makeMoveById()`](src/server/game/GameEngine.ts:3768), regardless of whether the underlying rules logic is provided by the legacy engine or the shared orchestrator adapter.
- TS↔Python rules parity: decision outcomes must match the canonical rules semantics and be representable in AI/parity traces.

## 2. State model

At a high level, the decision lifecycle composes four orthogonal state dimensions:

- Game lifecycle (session/game result).
- Turn and phase (rules-level state).
- Decision sub-state (whether a decision is pending / timed out / auto-resolved).
- Connection sub-state per player (connected vs disconnected with/without reconnect window).

### 2.1 Game lifecycle states

Canonical game status is carried on [`GameState.gameStatus`](src/shared/types/game.ts:545) and projected into a derived [`GameSessionStatus`](src/shared/stateMachines/gameSession.ts:1) by [`GameSession.recomputeSessionStatus()`](src/server/game/GameSession.ts:547).

| Logical state | GameState.gameStatus | SessionStatus.kind (typical)             | Owner                                                                                                                                                   | Notes                                                                                                                                       |
| ------------- | -------------------- | ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| Waiting       | `waiting`            | `waiting_for_players`                    | [`GameEngine`](src/server/game/GameEngine.ts:210) / DB                                                                                                  | Game created but not started; no decisions or timeouts are active.                                                                          |
| Active        | `active`             | `active_turn` or `active_decision_phase` | [`GameEngine`](src/server/game/GameEngine.ts:998) / [`GameSession`](src/server/game/GameSession.ts:609)                                                 | Normal play; all decision/timeout semantics in this spec apply.                                                                             |
| Paused        | `paused`             | `paused`                                 | [`GameEngine.pauseGame()`](src/server/game/GameEngine.ts:3373)                                                                                          | Clocks/timers are paused; decision-phase timers must be cleared.                                                                            |
| Completed     | `completed`          | `completed`                              | [`GameEngine.endGame()`](src/server/game/GameEngine.ts:3278) / [`GamePersistenceService.finishGame()`](src/server/services/GamePersistenceService.ts:1) | Terminal win/draw/forfeit result with a concrete [`GameResult`](src/shared/types/game.ts:560). Rating updates apply when `isRated` is true. |
| Abandoned     | `abandoned`          | `abandoned`                              | DB / [`GameSession.terminate()`](src/server/game/GameSession.ts:1259)                                                                                   | Terminal non-competitive end (e.g., cancelled lobby game, fatal host error). Rating should not change.                                      |

Constraints:

- Decision-phase timers in [`GameSession`](src/server/game/GameSession.ts:104) MUST NOT be active when `gameStatus !== 'active'`.
- `gameStatus === 'completed'` or `abandoned` implies no further player moves, decisions, or rating changes.

### 2.2 Turn and phase

Rules-level state for whose turn it is and what part of the rules pipeline is active is carried by [`GameState.currentPlayer`](src/shared/types/game.ts:514) and [`GameState.currentPhase`](src/shared/types/game.ts:513), with the allowed values defined by [`GamePhase`](src/shared/types/game.ts:51).

Phases are grouped as:

- **Interactive phases:** `ring_placement`, `movement`, `capture`, `chain_capture`.
- **Decision phases:** `line_processing`, `territory_processing`.

Phase transitions are managed by [`GameEngine.advanceGame()`](src/server/game/GameEngine.ts:3166) and, in orchestrator-backed flows, by the shared turn engine wrapped in [`TurnEngineAdapter`](src/server/game/turn/TurnEngineAdapter.ts:1) via [`GameEngine.processMoveViaAdapter()`](src/server/game/GameEngine.ts:786).

Invariants:

- Interactive phases must satisfy `INV-ACTIVE-NO-MOVES`: [`GameEngine.getValidMoves()`](src/server/game/GameEngine.ts:3408) will invoke [`GameEngine.resolveBlockedStateForCurrentPlayerForTesting()`](src/server/game/GameEngine.ts:4098) if no moves are available while `gameStatus === 'active'`.
- Decision phases must never be observable with zero canonical decision moves for the current player. When no decision moves exist, [`GameEngine.stepAutomaticPhasesForTesting()`](src/server/game/GameEngine.ts:4350) or turn-advancement must transition to the next phase or end the game.

### 2.3 Decision sub-states

Decision sub-state is a conceptual overlay on top of `GameState` and is tracked concretely by `GameSession`'s decision-phase timeout fields and the presence/absence of canonical decision `Move`s in `GameEngine.getValidMoves()`.

| Decision sub-state               | Conditions                                                                                                                                                                                                                                                                                                                   | Owning module / data                                                                                                               | Transitions                                                                                                                                                                                 |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `NO_DECISION_PENDING`            | `gameStatus !== 'active'` OR `currentPhase` not in `{line_processing, territory_processing, chain_capture}` OR no decision moves for current human player                                                                                                                                                                    | [`GameEngine`](src/server/game/GameEngine.ts:3408)                                                                                 | Enters when game starts, after decisions resolve, or for AI turns.                                                                                                                          |
| `DECISION_PENDING`               | `gameStatus === 'active'`; `currentPhase` ∈ `{line_processing, territory_processing, chain_capture}`; current player is human; `GameEngine.getValidMoves()` exposes one or more decision-type `Move`s; [`GameSession.scheduleDecisionPhaseTimeout()`](src/server/game/GameSession.ts:1338) has set `decisionTimeout*` fields | [`GameSession`](src/server/game/GameSession.ts:104)                                                                                | Entered after any move that yields a decision surface; leaves on move application, phase change, game end, or explicit timeout handling.                                                    |
| `DECISION_TIMED_OUT` (ephemeral) | Internal moment when `decisionTimeoutHandle` fires and [`GameSession.handleDecisionPhaseTimedOut()`](src/server/game/GameSession.ts:1512) begins executing                                                                                                                                                                   | [`GameSession`](src/server/game/GameSession.ts:1512)                                                                               | Immediately transitions to `DECISION_AUTO_RESOLVED` or back to `NO_DECISION_PENDING` if guard checks fail.                                                                                  |
| `DECISION_AUTO_RESOLVED`         | A canonical `Move` has been auto-selected and applied on behalf of the player, and [`DecisionAutoResolvedMeta`](src/shared/types/websocket.ts:78) has been attached to the last move                                                                                                                                         | [`GameSession`](src/server/game/GameSession.ts:1592) / [`GamePersistenceService`](src/server/services/GamePersistenceService.ts:1) | Visible to clients via `game_state.data.meta.diffSummary.decisionAutoResolved` and to history via `moveData.decisionAutoResolved`; next state is recomputed based on resulting `GameState`. |

Guards in [`GameSession.handleDecisionPhaseTimedOut()`](src/server/game/GameSession.ts:1512) enforce that auto-resolution only occurs when:

- The game is still `active`.
- The same player and phase are still current.
- The phase is still a designated timeout phase (`line_processing`, `territory_processing`, or `chain_capture`).
- The current player is still a human.
- The current phase still exposes decision moves.

If any guard fails, the timeout is treated as a no-op and the system returns to `NO_DECISION_PENDING`.

### 2.4 Connection sub-states

Per-player connection lifecycle is modelled by [`PlayerConnectionState`](src/shared/stateMachines/connection.ts:9) and stored in [`WebSocketServer.playerConnectionStates`](src/server/websocket/server.ts:141).

| Connection sub-state             | Conditions                                                                                                      | Owner / transitions                                                                                                                                                                         |
| -------------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `CONNECTED`                      | Player's WebSocket is currently joined to the game room.                                                        | [`WebSocketServer.handleJoinGame()`](src/server/websocket/server.ts:627) calls [`markConnected()`](src/shared/stateMachines/connection.ts:46) whenever a socket with `userId` joins a game. |
| `DISCONNECTED_PENDING_RECONNECT` | Player's socket disconnected from a game where they are a seated player; reconnection timeout window is active. | [`WebSocketServer.handleDisconnect()`](src/server/websocket/server.ts:858) calls [`markDisconnectedPendingReconnect()`](src/shared/stateMachines/connection.ts:74) and schedules a timeout. |
| `DISCONNECTED_EXPIRED`           | Player did not reconnect before `RECONNECTION_TIMEOUT_MS`; reconnect window expired.                            | [`WebSocketServer.handleReconnectionTimeout()`](src/server/websocket/server.ts:961) calls [`markDisconnectedExpired()`](src/shared/stateMachines/connection.ts:105).                        |

Current implementation effects on gameplay:

- On disconnect: a `player_disconnected` room event is emitted; no game state changes occur.
- While `DISCONNECTED_PENDING_RECONNECT`: gameplay continues; decision-phase timers and move clocks are not paused; transport-level `PlayerChoice`s for that player are not deliverable but will eventually time out.
- On `DISCONNECTED_EXPIRED`: all pending transport-level choices for that player are canceled via [`WebSocketInteractionHandler.cancelAllChoicesForPlayer()`](src/server/game/WebSocketInteractionHandler.ts:258). The game itself is **not** ended or forfeited today.

Testing references:

- Pure connection state transitions (`CONNECTED` ↔ `DISCONNECTED_PENDING_RECONNECT` → `DISCONNECTED_EXPIRED`) are covered by
  `tests/unit/stateMachines/connection.test.ts`.
- PlayerChoice lifecycle under normal response, timeout, and disconnect-driven cancellation is covered by
  `tests/unit/stateMachines/choice.test.ts` (see the DISCONNECT vs timeout vs fulfilled test block).
- Host-level reactions for AI and sessions (e.g., `GameSession.cancelInFlightAIRequest('player_disconnected')` and
  `GameSession.terminate('player_disconnected' | 'session_cleanup')`) are covered in
  `tests/unit/GameSession.coreOperations.test.ts` and `tests/unit/GameSession.branchCoverage.test.ts`.

Target lifecycle semantics (Section 4 and 6) add explicit mapping from `DISCONNECTED_EXPIRED` to game termination for certain configurations.

## 3. Timeout semantics

Timeouts in the host are layered:

- **Decision-phase timeouts** (per decision surface; owned by [`GameSession`](src/server/game/GameSession.ts:104)).
- **PlayerChoice timeouts** (per transport choice; owned by [`WebSocketInteractionHandler`](src/server/game/WebSocketInteractionHandler.ts:32)).
- **Move-clock timeouts** (per player timer; owned by [`GameEngine`](src/server/game/GameEngine.ts:3248)).
- **Reconnect window timeouts** (per player; owned by [`WebSocketServer`](src/server/websocket/server.ts:961)).

### 3.1 Decision-phase timeouts (line, territory, chain capture)

Decision-phase timeouts are configured via `config.decisionPhaseTimeouts` and scheduled by [`GameSession.scheduleDecisionPhaseTimeout()`](src/server/game/GameSession.ts:1338) whenever `GameState` indicates a decision surface for the active human player in one of:

- `line_processing` (line order and line reward decisions).
- `territory_processing` (territory region order and mandatory self-elimination).
- `chain_capture` (capture-direction prompts for mandatory follow-up segments).

#### 3.1.1 Clock start/stop rules

For all three decision types, the decision-phase timeout behaves as follows (current behaviour; target behaviour refines selection strategy but keeps these triggers):

- **Start:** after any move or state change that leaves the game `active` and in a decision phase for a human `currentPlayer`, when at least one canonical decision `Move` is returned by [`GameEngine.getValidMoves(currentPlayer)`](src/server/game/GameEngine.ts:3408) and [`GameSession.classifyDecisionSurface()`](src/server/game/GameSession.ts:1406) succeeds.
- **Duration:** `timeoutMs = config.decisionPhaseTimeouts.defaultTimeoutMs`; `warningBeforeMs = config.decisionPhaseTimeouts.warningBeforeTimeoutMs`.
- **Warning:** if `warningBeforeMs > 0`, [`GameSession.emitDecisionPhaseTimeoutWarning()`](src/server/game/GameSession.ts:1469) is scheduled at `timeoutMs - warningBeforeMs`, emitting a `decision_phase_timeout_warning` event with remaining time.
- **Stop/reset:** `resetDecisionPhaseTimeout()` is called whenever a new state is broadcast via [`GameSession.broadcastUpdate()`](src/server/game/GameSession.ts:759) or a terminal `game_over` is emitted. Any subsequent decision surface will reschedule a fresh timeout.
- **No timeout:** if the game is not `active`, the phase is not a timeout phase, the current player is not human, or there are no decision candidates, timeout scheduling is skipped.

#### 3.1.2 Behaviour on timeout

When the deadline elapses, [`GameSession.handleDecisionPhaseTimedOut()`](src/server/game/GameSession.ts:1512) executes the following algorithm:

1. Snapshot the pending phase, player, `choiceType`, and `choiceKind`, then clear timers via `resetDecisionPhaseTimeout()`.
2. Guard against stale timeouts by re-reading `GameState` and verifying:
   - `gameStatus === 'active'`.
   - `currentPlayer` and `currentPhase` still match the snapshot.
   - The phase is still a designated timeout phase (`line_processing`, `territory_processing`, or `chain_capture`).
   - The current player is still human.
3. Recompute valid moves and the current decision surface; if classification fails or yields no decision candidates, no auto-resolution occurs.
4. Select a canonical `Move` to apply.
5. Apply the move via [`RulesBackendFacade.applyMoveById()`](src/server/game/RulesBackendFacade.ts:1); on success:
   - Attach a [`DecisionAutoResolvedMeta`](src/shared/types/websocket.ts:78) record to the last move in `moveHistory`.
   - Persist the move via [`GameSession.persistMove()`](src/server/game/GameSession.ts:724).
   - Emit `decision_phase_timed_out` with the chosen `Move.id`.
   - Emit a `game_state` update that includes `meta.diffSummary.decisionAutoResolved`.
   - Invoke [`GameSession.maybePerformAITurn()`](src/server/game/GameSession.ts:848) if AI is next.

Current selection strategy (v1):

- For all decision types, the first candidate `Move` in the filtered candidate list is chosen (deterministic but not necessarily fair from a UX perspective).

Target selection semantics (P18.3-2 guidance):

- Selection remains deterministic but MUST be explicitly documented per decision type (e.g., territory regions sorted by size then position; lines by formation index) so orchestrator traces and UX communicate the same ordering. The spec does not require a randomness-based selection.

#### 3.1.3 Decision-type summary

| Decision type                | Phase                  | Canonical Move types                                                           | Timeout action (current)                                                                                                                                                                         | Timeout action (target)                                                                                                                                                      |
| ---------------------------- | ---------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Line – order                 | `line_processing`      | `process_line`                                                                 | Auto-apply first `process_line` move.                                                                                                                                                            | Same, but first move must be over a stable ordering of lines (e.g., by geometry index) to keep traces reproducible across hosts.                                             |
| Line – reward                | `line_processing`      | `choose_line_reward` and possible follow-up `eliminate_rings_from_stack`       | If `choose_line_reward` is pending, auto-apply first reward option. If an elimination is pending (line reward elimination), an `eliminate_rings_from_stack` move is selected as first candidate. | Same structure; selection of a stack for elimination MUST derive from a deterministic ordering of candidate stacks (e.g., ascending board key).                              |
| Territory – region order     | `territory_processing` | `process_territory_region`                                                     | Auto-apply first `process_territory_region` move.                                                                                                                                                | Same, ordering of candidate regions must be stable.                                                                                                                          |
| Territory – self-elimination | `territory_processing` | `eliminate_rings_from_stack` (when `pendingTerritorySelfElimination === true`) | Auto-apply first `eliminate_rings_from_stack` move if any are available.                                                                                                                         | Same, using deterministic stack ordering. When no eligible stacks remain, forced elimination from hand is applied automatically by the rules engine without emitting a Move. |
| Chain capture – direction    | `chain_capture`        | `continue_capture_segment`                                                     | Auto-apply first `continue_capture_segment` move when multiple continuation paths exist.                                                                                                         | Same general behaviour; selection policy may be updated to prefer geometrically minimal or sandbox-aligned continuation, but MUST remain deterministic.                      |

Decision-phase timeouts **never directly end a game**; they only select canonical moves. Any resulting victory (`ring_elimination`, `territory_control`, `last_player_standing`) is produced by the rules engine and reported via `GameResult`.

### 3.2 PlayerChoice timeouts

Transport-level `PlayerChoice` flows (e.g., legacy line-order prompts, ring-elimination dialogs in non-move-driven mode) are owned by [`WebSocketInteractionHandler`](src/server/game/WebSocketInteractionHandler.ts:32).

- When `requestChoice()` is called, a `pending` [`ChoiceStatus`](src/shared/stateMachines/choice.ts:15) is created with `deadlineAt = now + timeoutMs` (default 30s), and `player_choice_required` is emitted.
- If the client responds with `player_choice_response` before the deadline and the response passes validation, the choice becomes `fulfilled` via [`markChoiceFulfilled()`](src/shared/stateMachines/choice.ts:86).
- If the deadline elapses first, the choice becomes `expired` via [`markChoiceExpired()`](src/shared/stateMachines/choice.ts:132) and the Promise is rejected. No game move is auto-applied at this layer.
- If the server cancels a choice (for example, due to game end), `cancelChoice()` or `cancelAllChoicesForPlayer()` marks the choice as `canceled` and rejects the Promise.

Target semantics:

- New decision flows for line/territory/chain capture MUST be expressed through canonical Moves and decision-phase timeouts as described in 3.1, not through long-lived `PlayerChoice` prompts. `PlayerChoice` timeouts remain a transport concern and MUST NOT silently auto-apply moves.

### 3.2.1 Example: canceling in-flight AI / choice requests

Long-running decision or AI flows that involve async work (for example, AI
service calls or cross-host choice resolution) MUST cooperate with the shared
timeout/cancellation primitives in `src/shared/utils/timeout.ts` and
`src/shared/utils/cancellation.ts`.

#### 3.2.1.1 Typical pattern (engine-agnostic)

A typical pattern for an AI move request inside a state machine or handler is:

```ts
import { runWithTimeout } from '../shared/utils/timeout';
import { createCancellationSource } from '../shared/utils/cancellation';

const source = createCancellationSource();

// Optionally stash source somewhere so disconnect/leave/timeout can cancel it:
session.aiRequestState.current = source;

const result = await runWithTimeout(
  () => aiEngine.getAIMove(playerNumber, gameState, source.token),
  { timeoutMs: decisionDeadlineMs, token: source.token }
);

if (result.kind === 'ok') {
  // Apply the move as normal
  await gameEngine.makeMove(result.value, 'ai');
} else if (result.kind === 'timeout') {
  // Map to the existing deadline-exceeded / auto-resolve path in the
  // decision state machine (for example markTimedOut + default move).
} else if (result.kind === 'canceled') {
  // The request was canceled explicitly (disconnect, resign, leave).
  // Do not apply a move; let the surrounding state machine handle the
  // termination or reconnection semantics.
}
```

Notes:

- `CancellationSource.cancel(reason)` should be invoked when:
  - the player disconnects and their reconnect window expires, or
  - the player resigns/leaves while an AI/choice request is outstanding.
- Callers MUST NOT silently apply moves in the `timeout`/`canceled` cases;
  instead they should delegate to the existing decision and connection
  state machines to resolve the game (auto-resolution, abandonment, etc.).

#### 3.2.1.2 Current TS host implementation (`GameSession`)

The current TS backend host follows the same high-level contract but wires it
through the `GameSession` AI request state machine instead of a generic
`CancellationSource`:

- `GameSession.maybePerformAITurn()`:
  - Derives a per-session AI timeout budget from `config.aiService.requestTimeoutMs`
    (see `AI_SERVICE_REQUEST_TIMEOUT_MS` in `docs/ENVIRONMENT_VARIABLES.md`).
  - Starts an AI request lifecycle via `markQueued`/`markInFlight`, which
    records `deadlineAt` on `aiRequestState`.
  - Wraps `globalAIEngine.getAIMove(playerNumber, state)` in
    [`runWithTimeout`](src/shared/utils/timeout.ts:1) via
    `getAIMoveWithTimeout`, using that budget as `timeoutMs`. There is **no**
    additional jitter or artificial delay: AI moves are applied as soon as
    the service returns or the timeout is reached.
  - On deadline overrun, `isDeadlineExceeded` + `markTimedOut` drive the
    transition to a `timed_out` terminal state and trigger the documented
    fallback path (`handleNoMoveFromService` → local heuristic move or fatal
    failure).
- `GameSession.cancelInFlightAIRequest(reason)`:
  - Marks the request as `canceled` in `aiRequestState` and records the
    terminal `"canceled"` metric, then uses an internal `AbortController` to
    signal cancellation to any cooperative listeners.
  - Is invoked by `GameSession.terminate()` when sessions are torn down for
    reasons such as `session_cleanup` or `player_disconnected`, ensuring that
    any in-flight AI turn is treated as canceled and does not prolong the
    session.

`AI_THINK_TIME_MS` is **not** used anywhere in `GameSession` or
`globalAIEngine` to inject delay; all AI timing is enforced via explicit
timeouts (`AI_SERVICE_REQUEST_TIMEOUT_MS` / `aiService.requestTimeoutMs`) and
the AI request state machine.

Diagnostics and metrics mapping:

- Terminal `AIRequestState` kinds map to the `ringrift_ai_turn_request_terminal_total` counter via
  `MetricsService.recordAITurnRequestTerminal(kind, code?, aiErrorType?)`:
  - `completed` → `kind="completed"`, `code="none"` when no explicit code is provided.
  - `timed_out` → `kind="timed_out"`, typically with `code="AI_SERVICE_TIMEOUT"` and an `ai_error_type`
    such as `"timeout"` or `"deadline_exceeded"` when the underlying service budget is exceeded.
  - `failed` → `kind="failed"`, with `code`/`ai_error_type` distinguishing rules/validation errors
    from AI service errors (for example `code="AI_SERVICE_ERROR"`, `ai_error_type="server_error"`).
  - `canceled` → `kind="canceled"`, with `ai_error_type` reflecting the cancel reason (for example
    `"player_disconnected"`, `"session_cleanup"`, or `"game_terminated"`).
- Local vs service-backed fallbacks are tracked via `ringrift_ai_fallback_total` with `reason` labels
  such as `"timeout"`, `"no_move_from_service"`, `"overloaded"`, and `"validation_failed"`.
- Per-session aggregated AI diagnostics (`rulesServiceFailureCount`, `aiServiceFailureCount`,
  `aiFallbackMoveCount`, `aiQualityMode`, and the raw `aiRequestState` terminal kind and counters)
  are surfaced by `GameSession.getAIDiagnosticsSnapshotForTesting` and validated in:
  - `tests/unit/stateMachines/aiRequest.test.ts` (state machine-level transitions and terminals),
  - `tests/unit/GameSession.aiRequestState.test.ts` (host wiring over `AIRequestState`),
  - `tests/unit/GameSession.aiDiagnostics.test.ts` (session-level aggregation and `aiQualityMode`),
  - `tests/unit/MetricsService.aiRequestTerminals.test.ts` (Prometheus metrics wiring for
    `ringrift_ai_turn_request_terminal_total` and `ringrift_ai_request_latency_ms` / `_timeout_total`).

### 3.3 Move-clock timeouts (time control)

Per-player move clocks are implemented in [`GameEngine.startPlayerTimer()`](src/server/game/GameEngine.ts:3248) / [`GameEngine.stopPlayerTimer()`](src/server/game/GameEngine.ts:3269):

- For non-AI players, a Node timer is started with duration `player.timeRemaining` when the player's interactive turn begins.
- On expiry, [`GameEngine.forfeitGame()`](src/server/game/GameEngine.ts:3397) is invoked, which in turn calls `endGame(winner, 'resignation')`.
- Timers are cleared when a move is processed, the game is paused, or `endGame` runs.

Current limitations:

- `timeRemaining` is not decremented on each move today; timers behave more like an overall inactivity timeout than a precise chess clock.
- The `GameResult.reason` used for move-clock expiry is `'resignation'`, conflating explicit resign with timeout.

Target semantics:

- Move-clock expiry SHOULD be represented as `GameResult.reason === 'timeout'` rather than `'resignation'`.
- Rating code SHOULD treat timeout losses equivalently to resignations for competitive fairness.
- Precise time tracking (including increments) is out of scope for P18.3-1 but MUST be compatible with this forfeit model.

### 3.4 Reconnect window timeouts

Reconnect windows are owned by [`WebSocketServer`](src/server/websocket/server.ts:117) and tracked in `pendingReconnections`.

- When a player disconnects from an active game, `handleDisconnect()` emits `player_disconnected`, then, if the user is a seated player (not a spectator), starts a `RECONNECTION_TIMEOUT_MS` timer (30s by default) and marks connection state as `DISCONNECTED_PENDING_RECONNECT`.
- If the player calls `join_game` for the same game within the window, `handleJoinGame()` cancels the timeout, calls [`markConnected()`](src/shared/stateMachines/connection.ts:46), and emits `player_reconnected` with the player number.
- If the timer elapses first, [`handleReconnectionTimeout()`](src/server/websocket/server.ts:961) marks the state as `DISCONNECTED_EXPIRED`, cancels any pending choices for that player via `cancelAllChoicesForPlayer()`, and emits no further game events.

Target semantics for disconnect timeouts are defined in Section 5.

Diagnostics and metrics mapping (connection / session):

- The derived `GameSessionStatus` projection is exported via:
  - `ringrift_game_session_status_current{status}` – gauge of in-memory sessions by status kind (for example `waiting_for_players`, `active_turn`, `active_decision_phase`, `abandoned`, `completed`).
  - `ringrift_game_session_status_transitions_total{from,to}` – counter of status transitions, using `from="none"` for the initial projection when no prior status exists.
    These are wired by `GameSession.recomputeSessionStatus()` / `GameSessionManager` and validated in:
  - `tests/unit/MetricsService.test.ts` (Prometheus wiring),
  - `tests/unit/GameSession.gameSessionStatus.test.ts` (status projection),
  - `tests/unit/GameSession.abnormalTermination.metrics.test.ts` (termination-path transitions).
- WebSocket reconnect windows export:
  - `ringrift_websocket_reconnection_total{result="success"|"failed"|"timeout"}` – incremented when a reconnect succeeds within the window, when a reconnect attempt fails, or when the reconnect timer expires and `handleReconnectionTimeout()` runs.
    Behaviour is anchored by:
  - `tests/unit/MetricsService.test.ts` (metric definition), and
  - `tests/unit/WebSocketServer.connectionState.test.ts` (disconnect → reconnect vs timeout paths, including the timer-driven expiry case).
- Abandonment / abnormal termination surfaces:
  - `ringrift_game_session_abnormal_termination_total{reason}` – incremented when `GameSession.terminate(reason)` ends an `active` game for non-standard reasons such as `disconnect_timeout`, `session_cleanup`, or `internal_error`.
    This mapping is implemented in `GameSession.terminate()` / `handleAbandonmentForDisconnectedPlayer()` and validated in `tests/unit/GameSession.abnormalTermination.metrics.test.ts`.

## 4. Resign, leave, timeout, and forfeit semantics

This section defines how different termination causes map to `GameResult`, rating behaviour, and host modules.

### 4.1 Clean resign

**Current behaviour**

- HTTP `POST /games/:gameId/leave` on an **active** game (see [`routes/game.ts`](src/server/routes/game.ts:897)):
  - Validates the caller is a seated player via `assertUserIsGameParticipant`.
  - Updates the DB row to `status: 'completed'`, sets `endedAt`, but does **not**:
    - Call into `GameSession` or `GameEngine`.
    - Persist a `GameResult` with `winner` or `reason`.
    - Trigger rating updates.
- WebSocket `leave_game` only removes the socket from the room and emits `player_left`; it does not affect game outcome.

**Target behaviour**

- Clean resign SHOULD be expressed as a game-level forfeit processed by the active host:
  - The canonical flow is to call a dedicated resign API that resolves to [`GameEngine.endGame()`](src/server/game/GameEngine.ts:3278) with `reason: 'resignation'` and `winner` set to the opposing player.
  - `GamePersistenceService.finishGame()` MUST persist the `GameResult` and set `winnerId` accordingly so that rating updates are possible.
- The existing HTTP `leave` route SHOULD, for active games, be redefined as a wrapper that maps to this resign behaviour rather than performing a DB-only status change.
- For unrated games (`isRated === false`), the same `GameResult` should be recorded but `updatePlayerRatings()` MUST be a no-op.

### 4.2 Move-clock timeout

**Current behaviour**

- When a player's move-clock timer expires, [`GameEngine.forfeitGame()`](src/server/game/GameEngine.ts:3397) calls `endGame(winner, 'timeout')`, producing a `GameResult` with `reason === 'timeout'`.
- Rating updates remain stubbed at the engine level but are structurally attached to the terminal `GameResult` for consumption by `GamePersistenceService.finishGame` / `RatingService`.

**Target behaviour**

- Move-clock expiry MUST remain distinguishable from manual resign:
  - `GameResult.reason` MUST be `'timeout'` when the clock fires (already satisfied).
  - Rating and ladder logic MAY treat timeout and resignation identically, but observability (match logs, history, UX) should continue to differentiate them.
- This does not affect decision-phase timeouts, which do not end the game directly.

### 4.3 Disconnect timeout (reconnect window expiry)

**Current behaviour**

- When a player disconnects and fails to reconnect within `RECONNECTION_TIMEOUT_MS`, [`handleReconnectionTimeout()`](src/server/websocket/server.ts:961):
  - Marks the connection state as `DISCONNECTED_EXPIRED`.
  - Cancels all pending `PlayerChoice`s for that player.
  - Does **not** modify game state, emit `game_over`, or produce a `GameResult`.

**Target behaviour**

- For **rated** games where at least one human opponent remains connected and the game is still `active` when the reconnect window expires:
  - The disconnected player SHOULD be treated as having forfeited by abandonment.
  - The host MUST call into `GameEngine.endGame(winner, 'abandonment')` (or a thin wrapper) with `winner` set to a remaining opponent, and persist a `GameResult` with `reason: 'abandonment'`.
  - Rating MUST be updated using this `GameResult`.
- For **unrated** games, or games where all human players have `DISCONNECTED_EXPIRED`:
  - The game SHOULD transition to `gameStatus: 'abandoned'` with `GameResult.reason === 'abandonment'` but rating MUST NOT change.
- Any pending decision-phase timeout for the disconnected player MUST be cleared when abandonment is applied.

### 4.4 Decision-phase timeout while fully connected (AFK)

Decision-phase timeouts under 3.1 cover players who remain connected but fail to act in a decision phase.

- These timeouts are treated as **auto-decisions**, not forfeits.
- The game continues; victory, draw, or later resignation/timeout determine final rating behaviour.
- UX and telemetry SHOULD surface which decisions were auto-resolved both in real time (`decision_phase_timed_out`, `game_state.meta.diffSummary.decisionAutoResolved`) and via history ([`/games/:id/history`](src/server/routes/game.ts:1198)).

### 4.5 Summary matrix

| Scenario                                                  | Trigger                                                                                                      | GameResult.reason                              | Winner                | Rated game effect                                            |
| --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ---------------------------------------------- | --------------------- | ------------------------------------------------------------ |
| Clean resign                                              | Explicit resign API or active-game HTTP leave (target)                                                       | `'resignation'`                                | Opponent              | Rating updates applied.                                      |
| Move-clock timeout                                        | Move-clock expiry in [`startPlayerTimer()`](src/server/game/GameEngine.ts:3248) (target: reason `'timeout'`) | `'timeout'`                                    | Opponent              | Rating updates applied.                                      |
| Disconnect window expiry (rated)                          | `DISCONNECTED_EXPIRED` for one player while opponents remain and game still `active`                         | `'abandonment'`                                | Remaining opponent    | Rating updates applied.                                      |
| Disconnect window expiry (unrated or all players expired) | All relevant humans `DISCONNECTED_EXPIRED` or game unrated                                                   | `'abandonment'`                                | Optional or undefined | No rating updates.                                           |
| Decision-phase timeout (AFK)                              | Decision-phase deadline in `line_processing`, `territory_processing`, or `chain_capture`                     | _no direct GameResult; decision auto-resolved_ | n/a                   | None directly; subsequent normal termination governs rating. |

## 5. Orchestrator integration

The shared orchestrator is integrated via [`TurnEngineAdapter`](src/server/game/turn/TurnEngineAdapter.ts:1) and used by [`GameEngine.processMoveViaAdapter()`](src/server/game/GameEngine.ts:786). Decision lifecycle semantics in this spec are host-level and MUST hold regardless of whether the adapter or the legacy pipeline produced the underlying `GameState` transition.

Key integration points:

- All player-facing decisions in decision phases are expressed as canonical `Move`s surfaced by [`GameEngine.getValidMoves()`](src/server/game/GameEngine.ts:3408) with `useMoveDrivenDecisionPhases` enabled via [`GameEngine.enableMoveDrivenDecisionPhases()`](src/server/game/GameEngine.ts:447).
- `player_move_by_id` over WebSockets is the canonical transport for selecting these moves; [`WebSocketServer.handlePlayerMoveById()`](src/server/websocket/server.ts:806) delegates to [`GameSession.handlePlayerMoveById()`](src/server/game/GameSession.ts:676), which in turn calls [`RulesBackendFacade.applyMoveById()`](src/server/game/RulesBackendFacade.ts:1).
- Decision-phase timeouts in [`GameSession`](src/server/game/GameSession.ts:1338) operate purely on canonical Moves and do not depend on the underlying rules engine implementation.
- Orchestrator-specific decision points (for example, `elimination_target` surfaced through [`DecisionHandler`](src/server/game/GameEngine.ts:613)) either:
  - Are converted into canonical `Move`s and hence covered by this spec, or
  - Are auto-resolved for AI/soak harnesses without involving human transports.

Sequencing requirements:

- Once a terminal `GameResult` has been produced and persisted, no further Moves (including auto-resolved decisions) may be applied, and no further decision-phase timers may be scheduled.
- The orchestrator MUST NOT surface new decision requests after it has produced a terminal victory or abandonment result.
- For orchestrator-centric tests, termination induced by move-clock timeout or disconnect-induced abandonment MUST appear as a normal `GameResult` with reason `'timeout'` or `'abandonment'` and MUST be traceable through `GameHistoryEntry` and `/games/:id/history`.

## 6. Current vs target behaviour deltas

This section calls out intentional differences between current implementation and the target semantics defined above. Code/Debug tasks in P18.3-2 and P18.3-3 MUST use this as the change list.

1. **HTTP leave/resign vs engine-level resign**

- **Current (2025‑12‑01):**
  - [`POST /games/:gameId/leave`](src/server/routes/game.ts:897) now prefers to route active-game resignations through the host:
    - When a `WebSocketServer` instance is attached, the route calls
      `wsServer.handlePlayerResignFromHttp(gameId, userId)`, which:
      - Acquires the per-game lock via [`GameSessionManager.withGameLock`](src/server/game/GameSessionManager.ts:48),
      - Invokes [`GameSession.handlePlayerResignationByUserId`](src/server/game/GameSession.ts:676),
      - Calls [`GameEngine.resignPlayer`](src/server/game/GameEngine.ts:3405) → `endGame(winner, 'resignation')`, and
      - Finishes the game via [`GamePersistenceService.finishGame`](src/server/services/GamePersistenceService.ts:180).
    - For environments without an attached `WebSocketServer` (for example, some unit tests), the route falls back to the legacy
      DB-only behaviour: it infers a winner from the remaining seated players, calls [`RatingService.processGameResult`](src/server/services/RatingService.ts:1)
      directly for rated games, and marks the game `status: 'completed'` via `prisma.game.update`.
- **Target:** Active-game leave SHOULD, in all production environments, route exclusively through the engine/host path (GameSession + GameEngine)
  so that `GameResult` and rating semantics are driven by the same pipeline as move-based terminations. The DB-only + direct RatingService
  fallback is retained only for non-host test harnesses and may be removed or narrowed in a later pass.

2. **Move-clock timeout reason – RESOLVED (2025-12-01)**

- **Current:** [`GameEngine.forfeitGame()`](src/server/game/GameEngine.ts:3397) calls `endGame(winner, 'timeout')` when invoked by move-clock expiry, so `GameResult.reason === 'timeout'` for clock-based forfeits.
- **Target:** Same as current; timeout-based forfeits MUST remain distinguishable from explicit resignations for history and analytics, even if rating logic treats them equivalently.

3. **Disconnect window expiry semantics**

- **Current (2025‑12‑01):**
  - [`WebSocketServer.handleReconnectionTimeout()`](src/server/websocket/server.ts:961) now:
    - Marks the connection state as `DISCONNECTED_EXPIRED`,
    - Cancels all pending choices for the expired player via `cancelAllChoicesForPlayer`,
    - Under the per-game lock (`withGameLock`), inspects the current `GameState` and:
      - When the game is rated and at least one other human remains connected or within their own reconnect window, calls
        [`GameSession.handleAbandonmentForDisconnectedPlayer(playerNumber, true)`](src/server/game/GameSession.ts:706), which:
        - Uses [`GameEngine.abandonPlayer`](src/server/game/GameEngine.ts:3415) → `endGame(winner, 'abandonment')`,
        - Persists the result via `GamePersistenceService.finishGame`, and
        - Broadcasts `game_over` with a terminal `GameResult.reason === 'abandonment'`.
      - When the game is unrated or all human players have `DISCONNECTED_EXPIRED`, calls
        `handleAbandonmentForDisconnectedPlayer(playerNumber, false)`, which uses
        [`GameEngine.abandonGameAsDraw`](src/server/game/GameEngine.ts:3427) to mark the game as abandoned without a specific winner.
- **Target:** This behaviour matches the abandonment semantics defined in §4.3 for host-managed games. Future work may tighten how
  multi-player abandonment winners are selected and extend explicit test coverage across rated/unrated and multi-human scenarios.

4. **Decision selection determinism and ordering**

- **Current:** [`GameSession.handleDecisionPhaseTimedOut()`](src/server/game/GameSession.ts:1512) selects the first decision candidate in the raw `getValidMoves()` list, whose ordering is not documented as stable across hosts and engines.
- **Target:** The spec requires deterministic, documented ordering of decision candidates per type (line order, line reward, region order, self-elimination, chain capture). Implementation must sort or otherwise normalise candidate lists so that auto-resolution is fully reproducible and matches orchestrator traces.

5. **Decision vs transport choice timeouts**

- **Current:** Both decision-phase timeouts (host-level) and `PlayerChoice` timeouts (transport-level) exist; some legacy flows still rely on `PlayerChoice` for line/territory decisions.
- **Target:** All line/territory/chain-capture decisions presented to humans MUST be represented as canonical Moves on top of the orchestrator/engine and governed by decision-phase timeouts as in Section 3.1. `PlayerChoice` SHOULD NOT be the primary mechanism for these decisions in production; it remains for legacy flows and AI/shared tooling only.

6. **Disconnect impact on decision timers**

- **Current:** Decision-phase timers in [`GameSession`](src/server/game/GameSession.ts:1338) are independent of connection state; a disconnected player's decision may be auto-resolved while still within the reconnect window, and reconnect timeout later only cancels transport choices.
- **Target:** The spec accepts continued decision-phase timing during disconnects but requires that once a player has reached `DISCONNECTED_EXPIRED` and the game is still `active`, the game must transition to abandonment as in 4.3, and any remaining decision timers for that player must be cleared.

7. **Completed-game phase normalisation in edge flows**

- **Current:** `endGame()` normalises `currentPhase` to `ring_placement`, but some legacy flows (e.g., test-only automatic territory processing in [`GameEngine.stepAutomaticPhasesForTesting()`](src/server/game/GameEngine.ts:4350)) may momentarily leave `gameStatus !== 'active'` with `currentPhase === 'territory_processing'` before final cleanup.
- **Target:** All terminal flows, including those triggered by abandonment and forced elimination, MUST ensure that any final persisted `GameState` has `gameStatus !== 'active'` and `currentPhase === 'ring_placement'` to keep phase-consistency invariants trivial for consumers.

## 7. Versioning and references

- This spec is versioned as **P18.3-1 v1**. Any subsequent behavioural change to decisions, timeouts, reconnect semantics, or resign/leave mapping MUST be reflected here and referenced from PASS18 docs.
- PASS18 planning docs:
  - [`PASS18_REMEDIATION_PLAN.md`](docs/PASS18_REMEDIATION_PLAN.md:1)
  - [`PASS18_WORKING_NOTES.md`](docs/PASS18_WORKING_NOTES.md:1)
    will reference this file as the SSoT for decision lifecycle semantics.
- Related host/rules specs:
  - [`P18.1-1_CAPTURE_TERRITORY_HOST_MAP.md`](docs/P18.1-1_CAPTURE_TERRITORY_HOST_MAP.md:1)
  - [`P18.2-1_AI_RNG_PATHS.md`](docs/P18.2-1_AI_RNG_PATHS.md:1)
  - [`RULES_CANONICAL_SPEC.md`](RULES_CANONICAL_SPEC.md:1)
  - [`INVARIANTS_AND_PARITY_FRAMEWORK.md`](docs/INVARIANTS_AND_PARITY_FRAMEWORK.md:1)
