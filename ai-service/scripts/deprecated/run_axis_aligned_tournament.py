#!/usr/bin/env python
"""Axis-aligned heuristic tournament harness for RingRift.

This script runs a structured tournament between:
- All axis-aligned heuristic profiles generated by
  `scripts/generate_axis_aligned_profiles.py`, and
- Optionally, the baseline `BASE_V1_BALANCED_WEIGHTS` profile.

Key properties
==============
- Discovers single-factor (axis-aligned) profiles from a directory
  (default: logs/axis_aligned/profiles/).
- Supports one or more board types (square8, square19, hex).
- Uses the canonical rules pipeline (DefaultRulesEngine + GameEngine) and
  HeuristicAI with randomness disabled.
- Runs a symmetric, colour-balanced schedule: for each unordered pair of
  participants and each board, plays N games with A as player 1 vs B as
  player 2 and N games with roles swapped, where
  N = games_per_pair // 2.
- Produces a JSON summary with per-board, per-pair W/D/L matrices and
  average move counts.

Usage
=====

From ``ai-service/``::

    python scripts/generate_axis_aligned_profiles.py
    python scripts/run_axis_aligned_tournament.py \\
        --include-baseline \\
        --boards square8 \\
        --games-per-pair 10

"""

from __future__ import annotations

import argparse
import json
import os
import sys
import time
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Optional

# Allow imports from app/ when run from the ai-service root.
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.ai.heuristic_ai import HeuristicAI  # type: ignore
from app.ai.heuristic_weights import (  # type: ignore
    BASE_V1_BALANCED_WEIGHTS,
    HeuristicWeights,
)
from app.models import (  # type: ignore
    AIConfig,
    BoardState,
    BoardType,
    GamePhase,
    GameState,
    GameStatus,
    Player,
    TimeControl,
)
from app.rules.core import BOARD_CONFIGS  # type: ignore
from app.rules.default_engine import (  # type: ignore
    DefaultRulesEngine,
)
from app.utils.progress_reporter import SoakProgressReporter

DEFAULT_PROFILES_DIR = os.path.join("logs", "axis_aligned", "profiles")
DEFAULT_RESULTS_DIR = os.path.join("logs", "axis_aligned", "results")


BOARD_NAME_TO_TYPE: dict[str, BoardType] = {
    "square8": BoardType.SQUARE8,
    "square19": BoardType.SQUARE19,
    "hex": BoardType.HEXAGONAL,
}


@dataclass
class Participant:
    """Internal representation of a tournament participant."""

    id: str
    weights: HeuristicWeights
    meta: dict[str, Any]
    is_baseline: bool = False


def _create_heuristic_ai_with_weights(
    player_number: int,
    weights: HeuristicWeights,
    *,
    difficulty: int = 5,
    rng_seed: int | None = None,
) -> HeuristicAI:
    """Create a HeuristicAI instance with custom weights applied.

    This mirrors the helper used by the CMA-ES harness but is kept
    self-contained to avoid introducing additional runtime dependencies
    (e.g. the ``cma`` package) into this diagnostic script.
    """
    ai = HeuristicAI(
        player_number,
        AIConfig(
            difficulty=difficulty,
            think_time=0,
            randomness=0.0,
            rngSeed=rng_seed,
            heuristic_profile_id=None,
        ),
    )
    # Override weights on the instance
    for name, value in weights.items():
        setattr(ai, name, value)
    return ai


def _create_game_state(
    board_type: BoardType,
    seed: int | None,
) -> GameState:
    """Create an initial GameState for self-play on the given board.

    This closely mirrors
    :func:`scripts.run_cmaes_optimization.create_game_state` to keep
    tournament behaviour aligned with the training harness while
    remaining self-contained.
    """
    config = BOARD_CONFIGS.get(board_type, BOARD_CONFIGS[BoardType.SQUARE8])
    size = config.size
    rings_per_player = config.rings_per_player

    now = datetime.now()

    board = BoardState(
        type=board_type,
        size=size,
        stacks={},
        markers={},
        collapsedSpaces={},
        eliminatedRings={},
    )

    players = [
        Player(
            id=f"player{i}",
            username=f"AI {i}",
            type="ai",
            playerNumber=i,
            isReady=True,
            timeRemaining=600000,
            aiDifficulty=5,
            ringsInHand=rings_per_player,
            eliminatedRings=0,
            territorySpaces=0,
        )
        for i in (1, 2)
    ]

    state = GameState(
        id="axis-aligned-tournament",
        boardType=board_type,
        rngSeed=seed,
        board=board,
        players=players,
        currentPhase=GamePhase.RING_PLACEMENT,
        currentPlayer=1,
        moveHistory=[],
        timeControl=TimeControl(initialTime=600, increment=5, type="standard"),
        gameStatus=GameStatus.ACTIVE,
        createdAt=now,
        lastMoveAt=now,
        isRated=False,
        maxPlayers=2,
        totalRingsInPlay=0,
        totalRingsEliminated=0,
        victoryThreshold=18,  # RR-CANON-R061: ringsPerPlayer
        territoryVictoryThreshold=33,  # >50% of 64 spaces
        chainCaptureState=None,
        mustMoveFromStackKey=None,
        zobristHash=None,
        lpsRoundIndex=0,
        lpsExclusivePlayerForCompletedRound=None,
    )
    return state


def play_single_game_pair(
    board_type: BoardType,
    max_moves: int,
    p1_weights: HeuristicWeights,
    p2_weights: HeuristicWeights,
    seed: int,
) -> tuple[int, int]:
    """Play a single game between two heuristic weight profiles.

    Parameters
    ----------
    board_type:
        BoardType enum for this game.
    max_moves:
        Maximum number of moves before declaring a draw.
    p1_weights:
        Heuristic weights for player 1 (P1).
    p2_weights:
        Heuristic weights for player 2 (P2).
    seed:
        Integer seed used to initialise RNG fields on the GameState and AIs.
        The tournament driver derives this deterministically from a base seed,
        board index, and global game index. With randomness=0.0, this mainly
        serves future extensions and explicit seeding of tie-breakers.

    Returns
    -------
    Tuple[int, int]
        (result_for_p1, move_count) where result_for_p1 is:
        - +1 if P1 wins,
        -  0 if draw (including max-moves cutoff),
        - -1 if P1 loses.
    """
    # Derive per-player RNG seeds from the base seed to keep behaviour
    # deterministic but independent per side.
    seed_p1 = seed
    seed_p2 = seed + 1

    game_state = _create_game_state(board_type, seed=seed)
    rules_engine = DefaultRulesEngine()
    move_count = 0

    ai_p1 = _create_heuristic_ai_with_weights(
        1,
        p1_weights,
        difficulty=5,
        rng_seed=seed_p1,
    )
    ai_p2 = _create_heuristic_ai_with_weights(
        2,
        p2_weights,
        difficulty=5,
        rng_seed=seed_p2,
    )

    while game_state.game_status == GameStatus.ACTIVE and move_count < max_moves:
        current_player = game_state.current_player
        current_ai = ai_p1 if current_player == 1 else ai_p2
        current_ai.player_number = current_player

        move = current_ai.select_move(game_state)
        if not move:
            # No valid moves - opponent wins
            game_state.game_status = GameStatus.COMPLETED
            game_state.winner = 2 if current_player == 1 else 1
            break

        game_state = rules_engine.apply_move(game_state, move)
        move_count += 1

    if game_state.game_status != GameStatus.COMPLETED:
        # Draw due to move limit
        return 0, move_count

    winner = game_state.winner
    if winner == 1:
        return 1, move_count
    if winner == 2:
        return -1, move_count
    return 0, move_count


def load_axis_aligned_participants(
    profiles_dir: str,
    include_baseline: bool = False,
) -> list[Participant]:
    """Discover axis-aligned profiles under ``profiles_dir``.

    Each JSON file is expected to have the schema::

        {
          "weights": { ... all HEURISTIC_WEIGHT_KEYS ... },
          "meta": {
            "factor": "WEIGHT_STACK_CONTROL",
            "sign": "pos",
            "base_magnitude": 3.5
          }
        }

    The participant ``id`` is derived from::

        f"{meta['factor']}_{meta['sign']}"

    when both keys are present in ``meta``; otherwise we fall back to the
    filename stem.

    When ``include_baseline`` is true, an additional baseline participant
    using :data:`BASE_V1_BALANCED_WEIGHTS` is prepended.
    """
    participants: list[Participant] = []

    if not os.path.isdir(profiles_dir):
        raise FileNotFoundError("Profiles dir does not exist or is not a directory: " f"{profiles_dir!r}")

    baseline_keys = set(BASE_V1_BALANCED_WEIGHTS.keys())

    # Deterministic ordering for reproducibility.
    for name in sorted(os.listdir(profiles_dir)):
        if not name.endswith(".json"):
            continue
        path = os.path.join(profiles_dir, name)
        if not os.path.isfile(path):
            continue

        with open(path, encoding="utf-8") as f:
            payload = json.load(f)

        weights_obj = payload.get("weights")
        if not isinstance(weights_obj, dict):
            raise ValueError("Profile " f"{path!r} is missing a 'weights' object or it is not a dict")

        # Ensure schema compatibility with BASE_V1_BALANCED_WEIGHTS.
        weight_keys = set(weights_obj.keys())
        if weight_keys != baseline_keys:
            missing = sorted(baseline_keys - weight_keys)
            extra = sorted(weight_keys - baseline_keys)
            raise ValueError(
                f"Profile {path!r} weight keys mismatch baseline schema: " f"missing={missing}, extra={extra}"
            )

        # Normalise weights to float values.
        weights: HeuristicWeights = {str(k): float(v) for k, v in weights_obj.items()}

        meta = payload.get("meta") or {}
        factor = meta.get("factor")
        sign = meta.get("sign")
        if isinstance(factor, str) and isinstance(sign, str):
            pid = f"{factor}_{sign}"
        else:
            pid = os.path.splitext(name)[0]

        participants.append(
            Participant(
                id=pid,
                weights=weights,
                meta=dict(meta),
                is_baseline=False,
            )
        )

    if include_baseline:
        baseline = Participant(
            id="baseline_v1_balanced",
            weights=dict(BASE_V1_BALANCED_WEIGHTS),
            meta={"source": "BASE_V1_BALANCED_WEIGHTS"},
            is_baseline=True,
        )
        # Prepend baseline so it appears first in players list / logs.
        participants.insert(0, baseline)

    return participants


def _update_pair_stats(
    agg: dict[str, dict[str, dict[str, Any]]],
    board_label: str,
    id_i: str,
    id_j: str,
    result_for_i: int,
    move_count: int,
) -> None:
    """Update per-board, per-ordered-pair statistics."""
    board_bucket = agg.setdefault(board_label, {})
    row = board_bucket.setdefault(id_i, {})
    entry = row.setdefault(
        id_j,
        {
            "wins": 0,
            "losses": 0,
            "draws": 0,
            "games": 0,
            "total_moves": 0,
        },
    )

    entry["games"] += 1
    entry["total_moves"] += move_count
    if result_for_i > 0:
        entry["wins"] += 1
    elif result_for_i < 0:
        entry["losses"] += 1
    else:
        entry["draws"] += 1


def run_axis_aligned_tournament(
    participants: list[Participant],
    board_names: list[str],
    *,
    games_per_pair: int,
    max_moves: int,
    base_seed: int,
    profiles_dir: str,
    include_baseline: bool,
) -> dict[str, Any]:
    """Run the axis-aligned tournament and return the JSON-serialisable
    payload.
    """
    if not participants:
        raise ValueError("No participants found for tournament")
    if games_per_pair <= 0:
        raise ValueError("games_per_pair must be > 0")

    # Resolve board types from CLI names.
    boards: list[tuple[str, BoardType]] = []
    for name in board_names:
        if name not in BOARD_NAME_TO_TYPE:
            raise ValueError(f"Unknown board name {name!r}; expected one of " f"{sorted(BOARD_NAME_TO_TYPE.keys())}")
        boards.append((name, BOARD_NAME_TO_TYPE[name]))

    games_per_direction = games_per_pair // 2
    n_players = len(participants)
    n_pairs = n_players * (n_players - 1) // 2

    agg_results: dict[str, dict[str, dict[str, Any]]] = {}
    global_game_index = 0

    # Calculate total games across all boards
    total_games_all_boards = len(boards) * n_pairs * games_per_pair

    # Initialize progress reporter for time-based progress output (~10s intervals)
    progress_reporter = SoakProgressReporter(
        total_games=total_games_all_boards,
        report_interval_sec=10.0,
        context_label=f"axis_aligned_{','.join(board_names)}",
    )

    # Tournament loop
    for board_index, (board_label, board_type) in enumerate(boards):
        total_games_for_board = n_pairs * games_per_pair
        print(f"[{board_label}] Playing {total_games_for_board} games...")

        for i in range(n_players):
            for j in range(i + 1, n_players):
                p_i = participants[i]
                p_j = participants[j]

                print(f"  Pair ({p_i.id} vs {p_j.id}): {games_per_pair} games")

                # i as P1, j as P2
                for _ in range(games_per_direction):
                    game_start_time = time.time()
                    seed = base_seed + board_index * 10_000 + global_game_index
                    result_p1, moves = play_single_game_pair(
                        board_type,
                        max_moves,
                        p_i.weights,
                        p_j.weights,
                        seed,
                    )
                    _update_pair_stats(
                        agg_results,
                        board_label,
                        p_i.id,
                        p_j.id,
                        result_p1,
                        moves,
                    )
                    _update_pair_stats(
                        agg_results,
                        board_label,
                        p_j.id,
                        p_i.id,
                        -result_p1,
                        moves,
                    )
                    global_game_index += 1
                    # Record game for progress reporting
                    game_duration = time.time() - game_start_time
                    progress_reporter.record_game(moves=moves, duration_sec=game_duration)

                # j as P1, i as P2
                for _ in range(games_per_direction):
                    game_start_time = time.time()
                    seed = base_seed + board_index * 10_000 + global_game_index
                    result_p1, moves = play_single_game_pair(
                        board_type,
                        max_moves,
                        p_j.weights,
                        p_i.weights,
                        seed,
                    )
                    _update_pair_stats(
                        agg_results,
                        board_label,
                        p_j.id,
                        p_i.id,
                        result_p1,
                        moves,
                    )
                    _update_pair_stats(
                        agg_results,
                        board_label,
                        p_i.id,
                        p_j.id,
                        -result_p1,
                        moves,
                    )
                    global_game_index += 1
                    # Record game for progress reporting
                    game_duration = time.time() - game_start_time
                    progress_reporter.record_game(moves=moves, duration_sec=game_duration)

    # Emit final progress summary
    progress_reporter.finish()

    # Finalise avg_moves and drop internal total_moves.
    for _board_label, by_player in agg_results.items():
        for _id_i, vs in by_player.items():
            for _id_j, stats in vs.items():
                games = stats.get("games", 0)
                total_moves = stats.pop("total_moves", 0)
                stats["avg_moves"] = float(total_moves) / games if games > 0 else 0.0

    created_at = datetime.now(timezone.utc).isoformat() + "Z"

    payload: dict[str, Any] = {
        "meta": {
            "created_at": created_at,
            "seed": base_seed,
            "boards": board_names,
            "games_per_pair": games_per_pair,
            "max_moves": max_moves,
            "profiles_dir": profiles_dir,
            "include_baseline": include_baseline,
        },
        "players": [
            {
                "id": p.id,
                "is_baseline": p.is_baseline,
                "meta": p.meta or {},
            }
            for p in participants
        ],
        "results": agg_results,
    }
    return payload


def _parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Run an axis-aligned heuristic tournament between diagnostic " "profiles and an optional baseline."
        )
    )
    parser.add_argument(
        "--profiles-dir",
        type=str,
        default=DEFAULT_PROFILES_DIR,
        help=("Directory containing axis-aligned profile JSON files " f"(default: {DEFAULT_PROFILES_DIR})."),
    )
    parser.add_argument(
        "--boards",
        type=str,
        default="square8",
        help=(
            "Comma-separated list of boards to play on; choices from "
            f"{sorted(BOARD_NAME_TO_TYPE.keys())}. Default: square8."
        ),
    )
    parser.add_argument(
        "--games-per-pair",
        type=int,
        default=20,
        help=("Total games to play per unordered pair per board " "(split evenly by colour). Default: 20."),
    )
    parser.add_argument(
        "--max-moves",
        type=int,
        default=200,
        help=("Maximum moves per game before declaring a draw " "(default: 200)."),
    )
    parser.add_argument(
        "--include-baseline",
        action="store_true",
        help=("Include the baseline_v1_balanced participant using " "BASE_V1_BALANCED_WEIGHTS."),
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=12345,
        help="Base RNG seed used to derive per-game seeds (default: 12345).",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="",
        help=(
            "Optional explicit output path for the tournament JSON summary. "
            "If omitted, a timestamped file will be created under "
            f"{DEFAULT_RESULTS_DIR}."
        ),
    )
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> None:
    args = _parse_args(argv)

    boards = [b.strip() for b in args.boards.split(",") if b.strip()]
    for b in boards:
        if b not in BOARD_NAME_TO_TYPE:
            raise SystemExit(f"Unknown board {b!r}; expected one of " f"{sorted(BOARD_NAME_TO_TYPE.keys())}")

    participants = load_axis_aligned_participants(
        args.profiles_dir,
        include_baseline=args.include_baseline,
    )

    axis_count = sum(1 for p in participants if not p.is_baseline)
    baseline_suffix = " + baseline" if args.include_baseline else ""

    games_per_direction = args.games_per_pair // 2

    print("=== Axis-aligned heuristic tournament ===")
    print(f"Profiles dir: {args.profiles_dir}")
    print(f"Boards: {', '.join(boards)}")
    print(f"Players: {axis_count}{baseline_suffix}")
    print(
        "Games per pair per board: "
        f"{args.games_per_pair} "
        f"({games_per_direction} as P1, {games_per_direction} as P2)"
    )
    print(f"Max moves per game: {args.max_moves}")
    print(f"Seed: {args.seed}")
    print()

    if len(participants) < 2:
        print("Not enough participants for a tournament " f"(found {len(participants)}). Exiting.")
        return

    payload = run_axis_aligned_tournament(
        participants,
        boards,
        games_per_pair=args.games_per_pair,
        max_moves=args.max_moves,
        base_seed=args.seed,
        profiles_dir=args.profiles_dir,
        include_baseline=args.include_baseline,
    )

    # Resolve output path
    if args.output:
        output_path = args.output
    else:
        ts = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
        os.makedirs(DEFAULT_RESULTS_DIR, exist_ok=True)
        output_path = os.path.join(
            DEFAULT_RESULTS_DIR,
            f"axis_aligned_tournament_{ts}.json",
        )

    os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2, sort_keys=True)

    print("Tournament complete. Results written to " f"{output_path}")


if __name__ == "__main__":  # pragma: no cover
    main()
