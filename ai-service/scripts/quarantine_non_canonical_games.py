#!/usr/bin/env python3
"""
Quarantine non-canonical games from training databases.

This script identifies games that were generated by non-canonical engines
(pre-canonical spec) and marks them as non_canonical_history in the
parity_status field.

Non-canonical sources identified:
- p2p: Old P2P orchestrator selfplay (pre-Dec 2025)
- p2p_hybrid: Hybrid engine selfplay
- p2p_gpu: Old GPU selfplay

Canonical sources (keep):
- selfplay_soak: Canonical engine test games
- canonical_*: Explicit canonical source prefix
- any source with passed parity_status

Usage:
    PYTHONPATH=. python scripts/quarantine_non_canonical_games.py \
        --db data/games/canonical_square8_2p.db \
        --dry-run

    # Commit changes
    PYTHONPATH=. python scripts/quarantine_non_canonical_games.py \
        --db data/games/canonical_square8_2p.db \
        --commit

December 28, 2025: Initial implementation for parity fix.
"""

from __future__ import annotations

import argparse
import logging
import sqlite3
import sys
from dataclasses import dataclass
from pathlib import Path

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)

# Sources known to be non-canonical (pre-canonical spec engines)
NON_CANONICAL_SOURCES = {
    "p2p",
    "p2p_hybrid",
    "p2p_gpu",
    "gpu_workers",  # Early GPU selfplay, may have issues
}

# Sources known to be canonical
CANONICAL_SOURCES = {
    "selfplay_soak",
    # Any source starting with "canonical_" is canonical
}


@dataclass
class QuarantineResult:
    """Result of quarantine operation."""
    total_games: int
    canonical_games: int
    non_canonical_games: int
    already_quarantined: int
    games_quarantined: int
    games_without_moves: int


def analyze_sources(conn: sqlite3.Connection) -> dict[str, int]:
    """Get game count by source."""
    cursor = conn.cursor()
    cursor.execute("""
        SELECT source, COUNT(*) FROM games GROUP BY source ORDER BY COUNT(*) DESC
    """)
    return {row[0]: row[1] for row in cursor.fetchall()}


def check_games_without_moves(conn: sqlite3.Connection) -> int:
    """Count games with no moves."""
    cursor = conn.cursor()
    cursor.execute("""
        SELECT COUNT(*) FROM games g
        WHERE NOT EXISTS (
            SELECT 1 FROM game_moves m WHERE m.game_id = g.game_id
        )
    """)
    return cursor.fetchone()[0]


def is_canonical_source(source: str | None) -> bool:
    """Check if source is known canonical."""
    if source is None:
        return False
    if source in CANONICAL_SOURCES:
        return True
    if source.startswith("canonical_"):
        return True
    return False


def is_non_canonical_source(source: str | None) -> bool:
    """Check if source is known non-canonical."""
    if source is None:
        return True  # Unknown source, treat as non-canonical
    return source in NON_CANONICAL_SOURCES


def quarantine_games(
    conn: sqlite3.Connection,
    dry_run: bool = True,
) -> QuarantineResult:
    """
    Quarantine non-canonical games.

    Returns QuarantineResult with details.
    """
    cursor = conn.cursor()

    # Get total games
    cursor.execute("SELECT COUNT(*) FROM games")
    total_games = cursor.fetchone()[0]

    # Get games without moves
    games_without_moves = check_games_without_moves(conn)

    # Get games already quarantined
    cursor.execute("""
        SELECT COUNT(*) FROM games
        WHERE parity_status = 'non_canonical_history'
    """)
    already_quarantined = cursor.fetchone()[0]

    # Count games by canonicality
    cursor.execute("SELECT game_id, source, parity_status FROM games")
    rows = cursor.fetchall()

    canonical_count = 0
    non_canonical_count = 0
    to_quarantine: list[str] = []

    for game_id, source, parity_status in rows:
        # Already processed
        if parity_status == 'non_canonical_history':
            continue
        if parity_status == 'passed':
            canonical_count += 1
            continue

        # Check source
        if is_canonical_source(source):
            canonical_count += 1
        elif is_non_canonical_source(source):
            non_canonical_count += 1
            to_quarantine.append(game_id)
        else:
            # Unknown source, check phase diversity as heuristic
            try:
                cursor.execute("""
                    SELECT COUNT(DISTINCT phase) FROM game_moves WHERE game_id = ?
                """, (game_id,))
                phase_count = cursor.fetchone()[0]
            except sqlite3.OperationalError:
                # Older schema without phase column - check move count instead
                cursor.execute("""
                    SELECT COUNT(*) FROM game_moves WHERE game_id = ?
                """, (game_id,))
                move_count = cursor.fetchone()[0]
                # Games without moves are non-canonical
                if move_count == 0:
                    non_canonical_count += 1
                    to_quarantine.append(game_id)
                else:
                    # Can't determine, assume canonical for now
                    canonical_count += 1
                continue

            # Canonical games should have multiple phases (typically 4-6)
            # Non-canonical games often have only 1 (all moves recorded as ring_placement)
            if phase_count <= 1:
                non_canonical_count += 1
                to_quarantine.append(game_id)
            else:
                canonical_count += 1

    # Report findings
    logger.info(f"Total games: {total_games}")
    logger.info(f"Games without moves: {games_without_moves}")
    logger.info(f"Already quarantined: {already_quarantined}")
    logger.info(f"Canonical games: {canonical_count}")
    logger.info(f"Non-canonical games to quarantine: {len(to_quarantine)}")

    # Show source breakdown of games to quarantine
    if to_quarantine:
        cursor.execute("""
            SELECT source, COUNT(*) FROM games
            WHERE game_id IN ({})
            GROUP BY source ORDER BY COUNT(*) DESC
        """.format(','.join('?' * len(to_quarantine))), to_quarantine)
        source_breakdown = cursor.fetchall()
        logger.info("Sources to quarantine:")
        for source, count in source_breakdown:
            logger.info(f"  {source}: {count}")

    # Apply quarantine
    games_quarantined = 0
    if not dry_run and to_quarantine:
        # Update in batches to avoid SQLite limits
        batch_size = 500
        for i in range(0, len(to_quarantine), batch_size):
            batch = to_quarantine[i:i + batch_size]
            placeholders = ','.join('?' * len(batch))
            cursor.execute(f"""
                UPDATE games
                SET parity_status = 'non_canonical_history',
                    parity_checked_at = datetime('now')
                WHERE game_id IN ({placeholders})
            """, batch)
            games_quarantined += cursor.rowcount

        conn.commit()
        logger.info(f"Quarantined {games_quarantined} games")

    return QuarantineResult(
        total_games=total_games,
        canonical_games=canonical_count,
        non_canonical_games=non_canonical_count,
        already_quarantined=already_quarantined,
        games_quarantined=games_quarantined if not dry_run else 0,
        games_without_moves=games_without_moves,
    )


def main():
    parser = argparse.ArgumentParser(
        description="Quarantine non-canonical games from training databases"
    )
    parser.add_argument(
        "--db",
        type=Path,
        required=True,
        help="Path to SQLite database",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        default=True,
        help="Check games without committing changes (default)",
    )
    parser.add_argument(
        "--commit",
        action="store_true",
        help="Actually commit quarantine to database",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose logging",
    )

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    if not args.db.exists():
        logger.error(f"Database not found: {args.db}")
        sys.exit(1)

    dry_run = not args.commit

    if dry_run:
        logger.info("DRY RUN - no changes will be made")
    else:
        logger.info("COMMIT MODE - changes will be written to database")

    conn = sqlite3.connect(args.db)

    try:
        # Analyze sources first
        logger.info(f"\nAnalyzing {args.db}...")
        sources = analyze_sources(conn)
        logger.info("Source distribution:")
        for source, count in sources.items():
            marker = " [NON-CANONICAL]" if is_non_canonical_source(source) else ""
            marker = " [CANONICAL]" if is_canonical_source(source) else marker
            logger.info(f"  {source}: {count}{marker}")

        # Run quarantine
        logger.info("\nRunning quarantine analysis...")
        result = quarantine_games(conn, dry_run=dry_run)

        logger.info(f"\n{'='*60}")
        logger.info(f"QUARANTINE SUMMARY")
        logger.info(f"{'='*60}")
        logger.info(f"Total games: {result.total_games}")
        logger.info(f"Canonical: {result.canonical_games}")
        logger.info(f"Non-canonical: {result.non_canonical_games}")
        logger.info(f"Games without moves: {result.games_without_moves}")
        logger.info(f"Already quarantined: {result.already_quarantined}")
        logger.info(f"Games quarantined this run: {result.games_quarantined}")

        if dry_run and result.non_canonical_games > 0:
            logger.info(f"\nRe-run with --commit to quarantine {result.non_canonical_games} games")

        if result.games_without_moves > 0:
            logger.warning(f"\n{result.games_without_moves} games have no moves - these are unusable for training")

    finally:
        conn.close()


if __name__ == "__main__":
    main()
