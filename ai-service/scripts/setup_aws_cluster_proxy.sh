#!/bin/bash
# setup_aws_cluster_proxy.sh
#
# Setup script for AWS EC2 instance to serve as reverse proxy for cluster.ringrift.ai
# This instance routes public traffic to the P2P cluster leader via Tailscale.
#
# PREREQUISITES:
# 1. Fresh Ubuntu 22.04 EC2 instance with public IP / Elastic IP
# 2. SSH access via key pair
# 3. Tailscale auth key (from https://login.tailscale.com/admin/settings/keys)
# 4. Route 53 hosted zone for ringrift.ai domain
#
# USAGE:
#   # First, copy this script to the instance:
#   scp setup_aws_cluster_proxy.sh ubuntu@<INSTANCE_IP>:/tmp/
#
#   # Then SSH in and run:
#   ssh ubuntu@<INSTANCE_IP>
#   chmod +x /tmp/setup_aws_cluster_proxy.sh
#   sudo TAILSCALE_AUTH_KEY=tskey-... /tmp/setup_aws_cluster_proxy.sh

set -e

echo "=== RingRift Cluster Proxy Setup ==="
echo ""

# Check for root
if [ "$EUID" -ne 0 ]; then
    echo "Error: Please run as root (sudo)"
    exit 1
fi

# Check for required env vars
if [ -z "$TAILSCALE_AUTH_KEY" ]; then
    echo "Error: TAILSCALE_AUTH_KEY environment variable required"
    echo "Get one from: https://login.tailscale.com/admin/settings/keys"
    exit 1
fi

DOMAIN="${CLUSTER_DOMAIN:-cluster.ringrift.ai}"
EMAIL="${CERTBOT_EMAIL:-admin@ringrift.ai}"

echo "Configuration:"
echo "  Domain: $DOMAIN"
echo "  Email: $EMAIL"
echo ""

# 1. Update system
echo "[1/6] Updating system packages..."
apt-get update && apt-get upgrade -y

# 2. Install required packages
echo "[2/6] Installing Nginx, certbot, and dependencies..."
apt-get install -y nginx certbot python3-certbot-nginx curl

# 3. Install Tailscale
echo "[3/6] Installing Tailscale..."
curl -fsSL https://tailscale.com/install.sh | sh

# Authenticate Tailscale
echo "Authenticating Tailscale..."
tailscale up --authkey="$TAILSCALE_AUTH_KEY" --accept-routes

# Verify Tailscale connection
echo "Waiting for Tailscale to connect..."
sleep 5
TAILSCALE_IP=$(tailscale ip -4 2>/dev/null || echo "")
if [ -z "$TAILSCALE_IP" ]; then
    echo "Warning: Could not get Tailscale IP. Check Tailscale status with: tailscale status"
else
    echo "Tailscale IP: $TAILSCALE_IP"
fi

# 4. Configure Nginx
echo "[4/6] Configuring Nginx..."

# Create initial config (HTTP only for certbot)
cat > /etc/nginx/sites-available/$DOMAIN << 'NGINX_HTTP'
server {
    listen 80;
    server_name DOMAIN_PLACEHOLDER;

    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    location / {
        return 200 'RingRift Cluster Proxy - Waiting for SSL setup';
        add_header Content-Type text/plain;
    }
}
NGINX_HTTP

# Replace placeholder with actual domain
sed -i "s/DOMAIN_PLACEHOLDER/$DOMAIN/g" /etc/nginx/sites-available/$DOMAIN

# Enable site
ln -sf /etc/nginx/sites-available/$DOMAIN /etc/nginx/sites-enabled/
rm -f /etc/nginx/sites-enabled/default

# Test and reload Nginx
nginx -t && systemctl reload nginx

# 5. Get SSL certificate
echo "[5/6] Obtaining SSL certificate from Let's Encrypt..."
certbot --nginx -d "$DOMAIN" --non-interactive --agree-tos --email "$EMAIL" --redirect

# 6. Install final Nginx configuration
echo "[6/6] Installing final Nginx configuration..."

cat > /etc/nginx/sites-available/$DOMAIN << 'NGINX_FULL'
# Nginx configuration for cluster.ringrift.ai
# Auto-generated by setup_aws_cluster_proxy.sh

upstream cluster_backend {
    server cluster-leader.internal:8770;
    keepalive 32;
}

server {
    listen 80;
    server_name DOMAIN_PLACEHOLDER;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name DOMAIN_PLACEHOLDER;

    # SSL configuration managed by certbot
    ssl_certificate /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Logging
    access_log /var/log/nginx/cluster.ringrift.ai.access.log;
    error_log /var/log/nginx/cluster.ringrift.ai.error.log;

    # Main location - proxy to cluster leader
    location / {
        # Use resolver for dynamic IP resolution via Route 53
        resolver 8.8.8.8 valid=10s;
        set $backend "http://DOMAIN_PLACEHOLDER:8770";

        proxy_pass $backend;
        proxy_http_version 1.1;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        proxy_connect_timeout 30s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering off;
    }

    # API endpoints with longer timeout
    location /api/ {
        resolver 8.8.8.8 valid=10s;
        set $backend "http://DOMAIN_PLACEHOLDER:8770";

        proxy_pass $backend;
        proxy_http_version 1.1;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_connect_timeout 60s;
        proxy_send_timeout 120s;
        proxy_read_timeout 120s;
    }

    # Health check
    location = /health {
        resolver 8.8.8.8 valid=10s;
        set $backend "http://DOMAIN_PLACEHOLDER:8770";

        proxy_pass $backend;
        proxy_http_version 1.1;
        proxy_set_header Host $host;

        proxy_connect_timeout 5s;
        proxy_send_timeout 5s;
        proxy_read_timeout 5s;
    }

    # Nginx status (internal only)
    location = /nginx_status {
        stub_status on;
        access_log off;
        allow 127.0.0.1;
        allow 10.0.0.0/8;
        allow 100.64.0.0/10;
        deny all;
    }
}
NGINX_FULL

# Replace placeholders
sed -i "s/DOMAIN_PLACEHOLDER/$DOMAIN/g" /etc/nginx/sites-available/$DOMAIN

# Test and reload
nginx -t && systemctl reload nginx

# Enable Nginx on boot
systemctl enable nginx

echo ""
echo "=== Setup Complete ==="
echo ""
echo "Next steps:"
echo ""
echo "1. Update Route 53 to point $DOMAIN to this instance's public IP"
echo ""
echo "2. On cluster nodes, set these environment variables:"
echo "   export RINGRIFT_ROUTE53_ZONE_ID=<your-hosted-zone-id>"
echo "   export RINGRIFT_CLUSTER_DOMAIN=$DOMAIN"
echo ""
echo "3. The P2P orchestrator will automatically update Route 53 when leader changes"
echo ""
echo "4. Test the proxy:"
echo "   curl -v https://$DOMAIN/health"
echo ""
echo "Logs:"
echo "   Access: /var/log/nginx/cluster.ringrift.ai.access.log"
echo "   Error:  /var/log/nginx/cluster.ringrift.ai.error.log"
echo ""
echo "Tailscale status: tailscale status"
echo "Nginx status: systemctl status nginx"
