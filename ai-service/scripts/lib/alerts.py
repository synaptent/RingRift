"""
Shared Alert Infrastructure

Provides common alert types, severity levels, and alert management
utilities used across monitoring scripts.

Usage:
    from scripts.lib.alerts import (
        AlertSeverity,
        AlertType,
        Alert,
        AlertManager,
        create_alert,
    )

    # Create an alert
    alert = create_alert(
        AlertSeverity.WARNING,
        AlertType.HIGH_DISK_USAGE,
        "Disk usage at 75%",
        details={"disk_percent": 75.0},
    )

    # Use alert manager for tracking and notifications
    manager = AlertManager(name="cluster_monitor")
    manager.add_alert(alert)
    manager.flush()  # Send pending notifications
"""

from __future__ import annotations

import json
import logging
import os
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional

logger = logging.getLogger(__name__)


class AlertSeverity(Enum):
    """Severity level for alerts."""
    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

    @property
    def level(self) -> int:
        """Return numeric level for comparison."""
        levels = {
            "debug": 0,
            "info": 1,
            "warning": 2,
            "error": 3,
            "critical": 4,
        }
        return levels[self.value]

    def __lt__(self, other: "AlertSeverity") -> bool:
        return self.level < other.level

    def __le__(self, other: "AlertSeverity") -> bool:
        return self.level <= other.level

    def __gt__(self, other: "AlertSeverity") -> bool:
        return self.level > other.level

    def __ge__(self, other: "AlertSeverity") -> bool:
        return self.level >= other.level


class AlertType(Enum):
    """Types of alerts that can be raised."""
    # Resource alerts
    HIGH_DISK_USAGE = "high_disk_usage"
    HIGH_MEMORY_USAGE = "high_memory_usage"
    HIGH_CPU_USAGE = "high_cpu_usage"
    HIGH_GPU_USAGE = "high_gpu_usage"
    LOW_DISK_SPACE = "low_disk_space"
    GPU_IDLE = "gpu_idle"
    GPU_HOT = "gpu_hot"

    # Cluster alerts
    LEADER_UNREACHABLE = "leader_unreachable"
    NODE_UNREACHABLE = "node_unreachable"
    NODE_DEGRADED = "node_degraded"
    ROLE_MISMATCH = "role_mismatch"

    # Training alerts
    TRAINING_FAILED = "training_failed"
    TRAINING_STALLED = "training_stalled"
    TRAINING_SLOW = "training_slow"
    LOSS_SPIKE = "loss_spike"
    GRADIENT_EXPLOSION = "gradient_explosion"

    # Data quality alerts
    DATA_CORRUPTION = "data_corruption"
    DATA_IMBALANCE = "data_imbalance"
    DATA_STALE = "data_stale"
    VALIDATION_FAILED = "validation_failed"
    HIGH_DRAW_RATE = "high_draw_rate"
    GAMES_AT_MOVE_LIMIT = "games_at_move_limit"
    NO_GAMES = "no_games"
    DATABASE_ERROR = "database_error"
    HIGH_MOVES_COUNT = "high_moves_count"

    # Elo/evaluation alerts
    ELO_REGRESSION = "elo_regression"
    ELO_STAGNATION = "elo_stagnation"
    MODEL_DEGRADATION = "model_degradation"

    # General alerts
    THRESHOLD_EXCEEDED = "threshold_exceeded"
    HEALTH_CHECK_FAILED = "health_check_failed"
    CONFIGURATION_ERROR = "configuration_error"
    UNKNOWN = "unknown"


@dataclass
class Alert:
    """An alert generated by a monitoring system."""
    severity: AlertSeverity
    alert_type: AlertType
    message: str
    timestamp: datetime = field(default_factory=datetime.now)
    details: Dict[str, Any] = field(default_factory=dict)
    source: str = ""
    acknowledged: bool = False

    def __str__(self) -> str:
        prefix = self.severity.value.upper()
        return f"[{prefix}] {self.message}"

    def __repr__(self) -> str:
        return f"Alert({self.severity.value}, {self.alert_type.value}, {self.message!r})"

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "severity": self.severity.value,
            "alert_type": self.alert_type.value,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "details": self.details,
            "source": self.source,
            "acknowledged": self.acknowledged,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Alert":
        """Create from dictionary."""
        return cls(
            severity=AlertSeverity(data["severity"]),
            alert_type=AlertType(data.get("alert_type", "unknown")),
            message=data["message"],
            timestamp=datetime.fromisoformat(data["timestamp"]) if "timestamp" in data else datetime.now(),
            details=data.get("details", {}),
            source=data.get("source", ""),
            acknowledged=data.get("acknowledged", False),
        )

    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> "Alert":
        """Create from JSON string."""
        return cls.from_dict(json.loads(json_str))


def create_alert(
    severity: AlertSeverity,
    alert_type: AlertType,
    message: str,
    details: Optional[Dict[str, Any]] = None,
    source: str = "",
) -> Alert:
    """Convenience function to create an alert."""
    return Alert(
        severity=severity,
        alert_type=alert_type,
        message=message,
        details=details or {},
        source=source,
    )


@dataclass
class AlertThresholds:
    """Configurable thresholds for alert generation."""
    disk_warning_percent: float = 65.0
    disk_critical_percent: float = 70.0
    memory_warning_percent: float = 80.0
    memory_critical_percent: float = 95.0
    cpu_warning_percent: float = 80.0
    cpu_critical_percent: float = 95.0
    gpu_temp_warning_c: int = 80
    gpu_temp_critical_c: int = 90
    gpu_idle_threshold_percent: float = 5.0
    elo_regression_threshold: float = 50.0
    training_stall_minutes: int = 30

    @classmethod
    def from_env(cls) -> "AlertThresholds":
        """Create from environment variables."""
        return cls(
            disk_warning_percent=float(os.getenv("RINGRIFT_DISK_WARNING", "65")),
            disk_critical_percent=float(os.getenv("RINGRIFT_DISK_CRITICAL", "70")),
            memory_warning_percent=float(os.getenv("RINGRIFT_MEMORY_WARNING", "80")),
            memory_critical_percent=float(os.getenv("RINGRIFT_MEMORY_CRITICAL", "95")),
            cpu_warning_percent=float(os.getenv("RINGRIFT_CPU_WARNING", "80")),
            cpu_critical_percent=float(os.getenv("RINGRIFT_CPU_CRITICAL", "95")),
        )


# Type alias for alert handlers
AlertHandler = Callable[[Alert], None]


class AlertManager:
    """Manages alert collection, deduplication, and notification."""

    def __init__(
        self,
        name: str,
        thresholds: Optional[AlertThresholds] = None,
        min_severity: AlertSeverity = AlertSeverity.INFO,
        dedup_window_seconds: int = 300,
    ):
        self.name = name
        self.thresholds = thresholds or AlertThresholds()
        self.min_severity = min_severity
        self.dedup_window_seconds = dedup_window_seconds

        self.alerts: List[Alert] = []
        self.alert_history: List[Alert] = []
        self._handlers: List[AlertHandler] = []
        self._last_alert_times: Dict[str, datetime] = {}

    def add_handler(self, handler: AlertHandler) -> None:
        """Add an alert handler (e.g., for Slack, email, logging)."""
        self._handlers.append(handler)

    def _should_dedupe(self, alert: Alert) -> bool:
        """Check if this alert should be deduplicated."""
        key = f"{alert.alert_type.value}:{alert.message}"
        last_time = self._last_alert_times.get(key)

        if last_time is None:
            return False

        elapsed = (alert.timestamp - last_time).total_seconds()
        return elapsed < self.dedup_window_seconds

    def add_alert(self, alert: Alert) -> bool:
        """Add an alert. Returns True if alert was added, False if deduplicated."""
        # Filter by minimum severity
        if alert.severity < self.min_severity:
            return False

        # Set source if not set
        if not alert.source:
            alert.source = self.name

        # Check deduplication
        if self._should_dedupe(alert):
            logger.debug(f"Deduplicated alert: {alert}")
            return False

        # Update last alert time
        key = f"{alert.alert_type.value}:{alert.message}"
        self._last_alert_times[key] = alert.timestamp

        # Add to lists
        self.alerts.append(alert)
        self.alert_history.append(alert)

        # Log the alert
        log_level = {
            AlertSeverity.DEBUG: logging.DEBUG,
            AlertSeverity.INFO: logging.INFO,
            AlertSeverity.WARNING: logging.WARNING,
            AlertSeverity.ERROR: logging.ERROR,
            AlertSeverity.CRITICAL: logging.CRITICAL,
        }.get(alert.severity, logging.INFO)

        # Use a safe extra dict that doesn't conflict with logging internals
        safe_extra = {
            "alert_severity": alert.severity.value,
            "alert_type": alert.alert_type.value,
            "alert_message": alert.message,
            "alert_details": alert.details,
            "alert_source": alert.source,
        }
        logger.log(log_level, f"Alert: {alert}", extra=safe_extra)

        return True

    def flush(self) -> List[Alert]:
        """Process pending alerts through handlers and clear."""
        pending = self.alerts.copy()

        for alert in pending:
            for handler in self._handlers:
                try:
                    handler(alert)
                except Exception as e:
                    logger.error(f"Alert handler error: {e}")

        self.alerts.clear()
        return pending

    def get_alerts(
        self,
        severity: Optional[AlertSeverity] = None,
        alert_type: Optional[AlertType] = None,
        since: Optional[datetime] = None,
    ) -> List[Alert]:
        """Get alerts matching criteria."""
        result = self.alert_history.copy()

        if severity is not None:
            result = [a for a in result if a.severity >= severity]

        if alert_type is not None:
            result = [a for a in result if a.alert_type == alert_type]

        if since is not None:
            result = [a for a in result if a.timestamp >= since]

        return result

    def clear_history(self) -> None:
        """Clear alert history."""
        self.alert_history.clear()
        self._last_alert_times.clear()

    def get_summary(self) -> Dict[str, Any]:
        """Get summary of alert activity."""
        by_severity = {}
        by_type = {}

        for alert in self.alert_history:
            sev = alert.severity.value
            by_severity[sev] = by_severity.get(sev, 0) + 1

            typ = alert.alert_type.value
            by_type[typ] = by_type.get(typ, 0) + 1

        return {
            "total_alerts": len(self.alert_history),
            "pending_alerts": len(self.alerts),
            "by_severity": by_severity,
            "by_type": by_type,
        }


# Common alert handlers

def log_handler(alert: Alert) -> None:
    """Handler that logs alerts."""
    logger.info(f"Alert: {alert}", extra=alert.to_dict())


def console_handler(alert: Alert) -> None:
    """Handler that prints alerts to console."""
    prefix = {
        AlertSeverity.DEBUG: "DEBUG",
        AlertSeverity.INFO: "INFO",
        AlertSeverity.WARNING: "WARNING",
        AlertSeverity.ERROR: "ERROR",
        AlertSeverity.CRITICAL: "CRITICAL",
    }.get(alert.severity, "INFO")
    print(f"[{prefix}] {alert.message}")


def file_handler(filepath: Path) -> AlertHandler:
    """Create a handler that appends alerts to a file."""
    def handler(alert: Alert) -> None:
        with open(filepath, "a") as f:
            f.write(alert.to_json() + "\n")
    return handler


# Resource checking helpers

def check_disk_alert(
    percent: float,
    thresholds: AlertThresholds,
    path: str = "/",
) -> Optional[Alert]:
    """Check disk usage and return alert if threshold exceeded."""
    if percent >= thresholds.disk_critical_percent:
        return create_alert(
            AlertSeverity.CRITICAL,
            AlertType.HIGH_DISK_USAGE,
            f"Disk usage critical: {percent:.1f}% on {path}",
            details={"disk_percent": percent, "path": path},
        )
    elif percent >= thresholds.disk_warning_percent:
        return create_alert(
            AlertSeverity.WARNING,
            AlertType.HIGH_DISK_USAGE,
            f"Disk usage high: {percent:.1f}% on {path}",
            details={"disk_percent": percent, "path": path},
        )
    return None


def check_memory_alert(
    percent: float,
    thresholds: AlertThresholds,
) -> Optional[Alert]:
    """Check memory usage and return alert if threshold exceeded."""
    if percent >= thresholds.memory_critical_percent:
        return create_alert(
            AlertSeverity.CRITICAL,
            AlertType.HIGH_MEMORY_USAGE,
            f"Memory usage critical: {percent:.1f}%",
            details={"memory_percent": percent},
        )
    elif percent >= thresholds.memory_warning_percent:
        return create_alert(
            AlertSeverity.WARNING,
            AlertType.HIGH_MEMORY_USAGE,
            f"Memory usage high: {percent:.1f}%",
            details={"memory_percent": percent},
        )
    return None


def check_cpu_alert(
    percent: float,
    thresholds: AlertThresholds,
) -> Optional[Alert]:
    """Check CPU usage and return alert if threshold exceeded."""
    if percent >= thresholds.cpu_critical_percent:
        return create_alert(
            AlertSeverity.CRITICAL,
            AlertType.HIGH_CPU_USAGE,
            f"CPU usage critical: {percent:.1f}%",
            details={"cpu_percent": percent},
        )
    elif percent >= thresholds.cpu_warning_percent:
        return create_alert(
            AlertSeverity.WARNING,
            AlertType.HIGH_CPU_USAGE,
            f"CPU usage high: {percent:.1f}%",
            details={"cpu_percent": percent},
        )
    return None
