#!/usr/bin/env python3
"""Deploy P2P systemd service to cluster nodes for automatic restart on crash.

This script:
1. Creates /etc/ringrift/node.conf with node-specific settings
2. Installs ringrift-p2p.service to /etc/systemd/system/
3. Enables and starts the service

Usage:
    python scripts/deploy_p2p_systemd.py                    # Deploy to all p2p_enabled nodes
    python scripts/deploy_p2p_systemd.py --nodes runpod-*   # Deploy to matching nodes
    python scripts/deploy_p2p_systemd.py --dry-run          # Preview actions
    python scripts/deploy_p2p_systemd.py --check            # Check service status
    python scripts/deploy_p2p_systemd.py --include-local    # Include local nodes
    python scripts/deploy_p2p_systemd.py --sudo             # Force sudo usage
"""

import argparse
import asyncio
import os
import sys
from fnmatch import fnmatch
from pathlib import Path

import yaml


# Service file content (embedded for easy deployment)
SYSTEMD_SERVICE = """[Unit]
Description=RingRift P2P Orchestrator
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
EnvironmentFile=/etc/ringrift/node.conf

# Kill any rogue orchestrator holding the port before starting (if lsof available)
ExecStartPre=/bin/bash -c 'if command -v lsof >/dev/null 2>&1; then pid=$(lsof -ti:${P2P_PORT:-8770} 2>/dev/null | head -1); if [ -n "$pid" ]; then echo "[ringrift-p2p] Killing process $pid on port ${P2P_PORT:-8770}"; kill -9 "$pid" 2>/dev/null || true; sleep 2; fi; fi'

# Start orchestrator
ExecStart=/bin/bash -c '\\
  RINGRIFT_PATH="${RINGRIFT_PATH:-/home/ubuntu/ringrift}"; \\
  RINGRIFT_PATH="${RINGRIFT_PATH%/ai-service}"; \\
  AI_SERVICE_PATH="$RINGRIFT_PATH/ai-service"; \\
  export PYTHONPATH="$AI_SERVICE_PATH"; \\
  PY="$AI_SERVICE_PATH/venv/bin/python"; \\
  if [ ! -x "$PY" ]; then PY="/usr/bin/python3"; fi; \\
  cd "$AI_SERVICE_PATH" && \\
  exec "$PY" scripts/p2p_orchestrator.py \\
    --node-id "${NODE_ID}" \\
    --port "${P2P_PORT:-8770}" \\
    --peers "${P2P_SEEDS:-${COORDINATOR_URL:-https://p2p.ringrift.ai}}" \\
    --ringrift-path "$RINGRIFT_PATH"'

Restart=always
RestartSec=10
TimeoutStartSec=120
TimeoutStopSec=30

# Logging
StandardOutput=append:/var/log/ringrift/p2p.log
StandardError=append:/var/log/ringrift/p2p.log

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
"""


def load_hosts_config():
    """Load distributed_hosts.yaml configuration."""
    config_path = Path(__file__).parent.parent / "config" / "distributed_hosts.yaml"
    with open(config_path) as f:
        return yaml.safe_load(f)


def build_seed_peers(config: dict) -> list[str]:
    """Build seed peers from the p2p_voters list in distributed_hosts.yaml."""
    voters = config.get("p2p_voters", []) or []
    hosts = config.get("hosts", {}) or {}
    peers: list[str] = []
    for node_id in voters:
        host_config = hosts.get(node_id, {})
        host = host_config.get("p2p_public_host") or host_config.get("ssh_host")
        if not host:
            continue
        port = int(host_config.get("p2p_port", 8770) or 8770)
        if "://" in str(host):
            peer = str(host)
        else:
            peer = f"http://{host}:{port}"
        if peer not in peers:
            peers.append(peer)
    return peers


def resolve_sudo_mode(host_config: dict, force_sudo: bool | None) -> bool:
    """Determine whether to use sudo on the target host."""
    if force_sudo is not None:
        return force_sudo
    return host_config.get("ssh_user", "root") != "root"


def build_ssh_cmd(host_config: dict) -> list[str]:
    """Build SSH command for a host."""
    ssh_host = host_config.get("ssh_host")
    ssh_port = host_config.get("ssh_port", 22)
    ssh_user = host_config.get("ssh_user", "root")
    ssh_key = host_config.get("ssh_key", "~/.ssh/id_ed25519")
    ssh_key = os.path.expanduser(ssh_key)

    return [
        "ssh",
        "-o", "ConnectTimeout=10",
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        "-o", "LogLevel=ERROR",
        "-p", str(ssh_port),
        "-i", ssh_key,
        f"{ssh_user}@{ssh_host}",
    ]


def get_node_conf(node_id: str, host_config: dict, seed_peers: list[str]) -> str:
    """Generate node.conf content for a node."""
    ringrift_path = host_config.get("ringrift_path", "~/ringrift/ai-service")
    # Normalize path (remove /ai-service suffix if present)
    if ringrift_path.endswith("/ai-service"):
        ringrift_path = ringrift_path[:-11]
    elif ringrift_path.endswith("ai-service"):
        ringrift_path = ringrift_path[:-10]

    seed_list = ",".join(seed_peers)

    return f"""# RingRift P2P Node Configuration
# Auto-generated by deploy_p2p_systemd.py

NODE_ID={node_id}
P2P_PORT=8770
P2P_SEEDS={seed_list}
RINGRIFT_PATH={ringrift_path}
"""


async def deploy_to_node(
    node_id: str,
    host_config: dict,
    seed_peers: list[str],
    dry_run: bool = False,
    force_sudo: bool | None = None,
) -> tuple[str, bool, str]:
    """Deploy systemd service to a single node."""
    ssh_cmd = build_ssh_cmd(host_config)
    node_conf = get_node_conf(node_id, host_config, seed_peers)
    use_sudo = resolve_sudo_mode(host_config, force_sudo)
    sudo_prefix = "sudo -n " if use_sudo else ""

    # Commands to run
    commands = f"""
set -e
# Create directories
{sudo_prefix}mkdir -p /etc/ringrift /var/log/ringrift
{"sudo -n true" if use_sudo else ":"}

# Write node.conf
cat << 'NODECONF' | {sudo_prefix}tee /etc/ringrift/node.conf >/dev/null
{node_conf}
NODECONF

# Write systemd service
cat << 'SERVICEEOF' | {sudo_prefix}tee /etc/systemd/system/ringrift-p2p.service >/dev/null
{SYSTEMD_SERVICE}
SERVICEEOF

# Reload systemd and enable service
{sudo_prefix}systemctl daemon-reload
{sudo_prefix}systemctl enable ringrift-p2p.service

# Stop existing P2P if running manually (not via systemd)
{sudo_prefix}pkill -f 'p2p_orchestrator.py' 2>/dev/null || true
sleep 2

# Start/restart service
{sudo_prefix}systemctl restart ringrift-p2p.service

# Wait and check status
sleep 3
{sudo_prefix}systemctl is-active ringrift-p2p.service && echo "SERVICE_OK" || echo "SERVICE_FAILED"
"""

    if dry_run:
        return (node_id, True, f"Would deploy to {node_id}")

    try:
        result = await asyncio.create_subprocess_exec(
            *ssh_cmd,
            commands,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await asyncio.wait_for(result.communicate(), timeout=60)
        stdout_text = stdout.decode().strip()
        stderr_text = stderr.decode().strip()

        if result.returncode == 0 and "SERVICE_OK" in stdout_text:
            return (node_id, True, "Deployed and running")
        else:
            return (node_id, False, f"Exit {result.returncode}: {stderr_text or stdout_text}")
    except asyncio.TimeoutError:
        return (node_id, False, "Timeout")
    except Exception as e:
        return (node_id, False, str(e))


async def check_node_status(node_id: str, host_config: dict) -> tuple[str, str, str]:
    """Check systemd service status on a node."""
    ssh_cmd = build_ssh_cmd(host_config)

    command = "systemctl is-active ringrift-p2p.service 2>/dev/null && systemctl show ringrift-p2p.service --property=ActiveEnterTimestamp 2>/dev/null | cut -d= -f2 || echo 'not-installed'"

    try:
        result = await asyncio.create_subprocess_exec(
            *ssh_cmd,
            command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, _ = await asyncio.wait_for(result.communicate(), timeout=15)
        output = stdout.decode().strip().split('\n')
        status = output[0] if output else "unknown"
        timestamp = output[1] if len(output) > 1 else ""
        return (node_id, status, timestamp)
    except asyncio.TimeoutError:
        return (node_id, "timeout", "")
    except Exception as e:
        return (node_id, f"error: {e}", "")


async def main():
    parser = argparse.ArgumentParser(description="Deploy P2P systemd service to cluster nodes")
    parser.add_argument("--nodes", help="Node pattern to match (e.g., 'runpod-*')")
    parser.add_argument("--dry-run", action="store_true", help="Preview actions without executing")
    parser.add_argument("--check", action="store_true", help="Check service status on nodes")
    parser.add_argument("--include-local", action="store_true", help="Include local nodes (default: false)")
    parser.add_argument("--sudo", action="store_true", help="Force sudo usage on remote nodes")
    parser.add_argument("--no-sudo", action="store_true", help="Disable sudo usage even for non-root users")
    parser.add_argument("--seeds", help="Override seed peers (comma-separated)")
    args = parser.parse_args()

    if args.sudo and args.no_sudo:
        print("Error: --sudo and --no-sudo are mutually exclusive", file=sys.stderr)
        sys.exit(2)

    force_sudo = True if args.sudo else False if args.no_sudo else None

    config = load_hosts_config()
    hosts = config.get("hosts", {})
    seed_peers = [s.strip() for s in (args.seeds or "").split(",") if s.strip()]
    if not seed_peers:
        seed_peers = build_seed_peers(config)
    if not seed_peers:
        print("Warning: No seed peers resolved from config; P2P bootstrap may be slow.", file=sys.stderr)

    # Filter to p2p_enabled nodes
    nodes_to_deploy = []
    for node_id, host_config in hosts.items():
        if not host_config.get("p2p_enabled", False):
            continue

        # Skip local nodes
        if not args.include_local:
            if node_id in ("local-mac", "mac-studio"):
                continue
            if host_config.get("ssh_host") == "localhost":
                continue

        # Pattern match if specified
        if args.nodes and not fnmatch(node_id, args.nodes):
            continue

        nodes_to_deploy.append((node_id, host_config))

    if not nodes_to_deploy:
        print("No nodes matched the criteria")
        sys.exit(1)

    print(f"Target nodes: {len(nodes_to_deploy)}")

    if args.check:
        # Check status mode
        print("\nChecking service status...\n")
        tasks = [check_node_status(nid, cfg) for nid, cfg in nodes_to_deploy]
        results = await asyncio.gather(*tasks)

        print(f"{'Node':<30} {'Status':<15} {'Started'}")
        print("-" * 80)
        for node_id, status, timestamp in sorted(results):
            status_icon = "✓" if status == "active" else "✗" if status in ("inactive", "failed") else "?"
            print(f"{node_id:<30} {status_icon} {status:<12} {timestamp}")

        active = sum(1 for _, s, _ in results if s == "active")
        print(f"\nActive: {active}/{len(results)}")
    else:
        # Deploy mode
        print("\nDeploying systemd service...\n")

        # Deploy in batches of 10 for stability
        batch_size = 10
        all_results = []

        for i in range(0, len(nodes_to_deploy), batch_size):
            batch = nodes_to_deploy[i:i + batch_size]
            tasks = [
                deploy_to_node(nid, cfg, seed_peers, args.dry_run, force_sudo=force_sudo)
                for nid, cfg in batch
            ]
            results = await asyncio.gather(*tasks)
            all_results.extend(results)

            for node_id, success, message in results:
                icon = "✓" if success else "✗"
                print(f"  {icon} {node_id}: {message}")

        succeeded = sum(1 for _, s, _ in all_results if s)
        print(f"\nDeployed: {succeeded}/{len(all_results)}")


if __name__ == "__main__":
    asyncio.run(main())
