[
  {
    "filePath": "/Users/armand/Development/RingRift/tests/e2e/error-recovery.e2e.spec.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/ban-ts-comment",
        "severity": 2,
        "message": "Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.",
        "line": 118,
        "column": 7,
        "nodeType": "Line",
        "messageId": "tsIgnoreInsteadOfExpectError",
        "endLine": 118,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "replaceTsIgnoreWithTsExpectError",
            "fix": {
              "range": [3887, 3940],
              "text": "// @ts-expect-error - accessing internal WebSocket tracking"
            },
            "desc": "Replace \"@ts-ignore\" with \"@ts-expect-error\"."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { test, expect } from '@playwright/test';\nimport {\n  generateTestUser,\n  registerUser,\n  loginUser,\n  registerAndLogin,\n  createGame,\n  waitForGameReady,\n} from './helpers/test-utils';\nimport { LoginPage, RegisterPage, GamePage } from './pages';\n\n/**\n * E2E Test Suite: Error Recovery\n * ============================================================================\n *\n * This suite tests error recovery scenarios:\n * - Network disconnection and reconnection\n * - WebSocket disconnection during gameplay\n * - API error responses (4xx/5xx)\n * - Session expiry and auth token invalidation\n * - Rate limiting responses\n * - Form validation errors\n *\n * INFRASTRUCTURE REQUIREMENTS:\n * - PostgreSQL running (for user persistence)\n * - Redis running (for session management)\n * - Dev server running on http://localhost:5173\n *\n * These tests use Playwright's network interception capabilities to simulate\n * various error conditions without requiring backend modifications.\n *\n * RUN COMMAND: npm run test:e2e -- error-recovery.e2e.spec.ts\n */\n\ntest.describe('Error Recovery - Network Failures', () => {\n  test.setTimeout(120_000);\n\n  test('handles temporary network disconnection gracefully', async ({ page, context }) => {\n    // Register and login a user\n    await registerAndLogin(page);\n\n    // Navigate to lobby\n    await page.getByRole('link', { name: /lobby/i }).click();\n    await page.waitForURL('**/lobby', { timeout: 15_000 });\n    await expect(page.getByRole('heading', { name: /Game Lobby/i })).toBeVisible({ timeout: 10_000 });\n\n    // Simulate network failure\n    await context.setOffline(true);\n\n    // Attempt to refresh games list (should fail gracefully)\n    const refreshButton = page.locator('button').filter({ hasText: /refresh/i });\n    if (await refreshButton.isVisible()) {\n      await refreshButton.click();\n    }\n\n    // Wait a moment for the error state to appear\n    await page.waitForTimeout(2000);\n\n    // Verify the page doesn't crash - should still show lobby structure\n    await expect(page.getByRole('heading', { name: /Game Lobby/i })).toBeVisible();\n\n    // Restore network\n    await context.setOffline(false);\n\n    // Wait for potential reconnection\n    await page.waitForTimeout(3000);\n\n    // Verify page is still functional after network restore\n    await expect(page.getByRole('heading', { name: /Game Lobby/i })).toBeVisible();\n  });\n\n  test('recovers page functionality after network restore', async ({ page, context }) => {\n    const loginPage = new LoginPage(page);\n    await loginPage.goto();\n    await loginPage.waitForReady();\n\n    // Go offline before attempting login\n    await context.setOffline(true);\n\n    // Attempt login (should fail/hang)\n    const user = generateTestUser();\n    await loginPage.fillEmail(user.email);\n    await loginPage.fillPassword(user.password);\n    await loginPage.clickLogin();\n\n    // Wait a moment\n    await page.waitForTimeout(2000);\n\n    // Restore network\n    await context.setOffline(false);\n\n    // Wait for potential error state\n    await page.waitForTimeout(3000);\n\n    // Page should still be usable - either showing login form or error\n    const loginFormOrError = page\n      .getByRole('heading', { name: /login/i })\n      .or(page.locator('.text-red-300, .text-red-400'));\n    await expect(loginFormOrError).toBeVisible({ timeout: 10_000 });\n  });\n});\n\ntest.describe('Error Recovery - WebSocket Disconnection', () => {\n  test.setTimeout(120_000);\n\n  test('handles WebSocket connection loss during game view', async ({ page }) => {\n    // Register and create a game\n    await registerAndLogin(page);\n    await createGame(page);\n    await waitForGameReady(page);\n\n    const gamePage = new GamePage(page);\n    await gamePage.assertConnected();\n\n    // Force close WebSocket connections via page evaluation\n    await page.evaluate(() => {\n      // Find and close any WebSocket connections\n      // @ts-ignore - accessing internal WebSocket tracking\n      const wsList = (window as any).__webSockets || [];\n      wsList.forEach((ws: WebSocket) => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.close(1000, 'Test forced disconnect');\n        }\n      });\n\n      // Also try to close via performance entries (if WebSocket is tracked)\n      // This is a fallback mechanism\n      performance.getEntriesByType('resource').forEach((entry) => {\n        if (entry.name.includes('ws://') || entry.name.includes('wss://')) {\n          // Resource exists, connection may be tracked elsewhere\n        }\n      });\n    });\n\n    // Wait for potential reconnection or error state\n    await page.waitForTimeout(5000);\n\n    // The board should still be visible (page shouldn't crash)\n    await expect(gamePage.boardView).toBeVisible({ timeout: 10_000 });\n  });\n\n  test.skip('shows reconnecting state on WebSocket disconnect', async ({ page }) => {\n    // SKIP: Requires backend WebSocket implementation to expose reconnection UI\n    // This test would verify that a \"Reconnecting...\" message appears\n    // when WebSocket connection is lost\n\n    await registerAndLogin(page);\n    await createGame(page);\n    await waitForGameReady(page);\n\n    // Would need to intercept and break WebSocket, then verify reconnect UI\n    // await expect(page.locator('text=/reconnecting/i')).toBeVisible();\n  });\n});\n\ntest.describe('Error Recovery - API Error Responses', () => {\n  test.setTimeout(120_000);\n\n  test('handles API 500 error responses gracefully', async ({ page, context }) => {\n    // First register a user normally\n    await registerAndLogin(page);\n\n    // Navigate to lobby\n    await page.getByRole('link', { name: /lobby/i }).click();\n    await page.waitForURL('**/lobby', { timeout: 15_000 });\n\n    // Intercept game API calls and return 500 error\n    await page.route('**/api/games**', (route) => {\n      route.fulfill({\n        status: 500,\n        contentType: 'application/json',\n        body: JSON.stringify({ error: 'Internal server error' }),\n      });\n    });\n\n    // Attempt to create a game (should show error)\n    await page.getByRole('button', { name: /\\+ Create Game/i }).click();\n    await expect(page.getByRole('heading', { name: /Create Backend Game/i })).toBeVisible({\n      timeout: 5_000,\n    });\n    await page.getByRole('button', { name: /^Create Game$/i }).click();\n\n    // Wait for error state\n    await page.waitForTimeout(3000);\n\n    // Should show error message or stay on form (not crash)\n    const formOrError = page\n      .getByRole('heading', { name: /Create Backend Game/i })\n      .or(page.locator('.text-red-300, .text-red-400, [class*=\"error\"]'));\n    await expect(formOrError).toBeVisible({ timeout: 10_000 });\n\n    // Remove the route to restore normal behavior\n    await page.unroute('**/api/games**');\n  });\n\n  test('handles API 400 bad request gracefully', async ({ page }) => {\n    await registerAndLogin(page);\n\n    // Navigate to lobby\n    await page.getByRole('link', { name: /lobby/i }).click();\n    await page.waitForURL('**/lobby', { timeout: 15_000 });\n\n    // Intercept and return 400 error\n    await page.route('**/api/games', (route) => {\n      if (route.request().method() === 'POST') {\n        route.fulfill({\n          status: 400,\n          contentType: 'application/json',\n          body: JSON.stringify({ error: 'Invalid game configuration' }),\n        });\n      } else {\n        route.continue();\n      }\n    });\n\n    // Attempt to create a game\n    await page.getByRole('button', { name: /\\+ Create Game/i }).click();\n    await expect(page.getByRole('heading', { name: /Create Backend Game/i })).toBeVisible({\n      timeout: 5_000,\n    });\n    await page.getByRole('button', { name: /^Create Game$/i }).click();\n\n    // Wait for error handling\n    await page.waitForTimeout(3000);\n\n    // Form should still be visible or error shown (page shouldn't crash)\n    const formVisible = await page.getByRole('heading', { name: /Create Backend Game/i }).isVisible();\n    const errorVisible = await page.locator('.text-red-300, .text-red-400, [class*=\"error\"]').isVisible();\n    expect(formVisible || errorVisible).toBeTruthy();\n\n    await page.unroute('**/api/games');\n  });\n\n  test('handles API 404 not found gracefully', async ({ page }) => {\n    await registerAndLogin(page);\n\n    // Try to navigate to a non-existent game\n    await page.goto('/game/non-existent-game-id-12345');\n\n    // Wait for error state\n    await page.waitForTimeout(3000);\n\n    // Should show error or redirect (not crash)\n    const errorOrRedirect = page\n      .locator('text=/not found/i')\n      .or(page.locator('text=/error/i'))\n      .or(page.getByRole('heading', { name: /lobby/i }))\n      .or(page.getByRole('heading', { name: /welcome/i }));\n\n    await expect(errorOrRedirect).toBeVisible({ timeout: 15_000 });\n  });\n});\n\ntest.describe('Error Recovery - Session Expiry', () => {\n  test.setTimeout(120_000);\n\n  test('redirects to login on session expiry', async ({ page, context }) => {\n    // Register and login\n    const user = await registerAndLogin(page);\n\n    // Verify we're authenticated\n    await expect(page.getByRole('button', { name: /logout/i })).toBeVisible();\n\n    // Clear all cookies to simulate session expiry\n    await context.clearCookies();\n\n    // Navigate to a protected page (lobby)\n    await page.getByRole('link', { name: /lobby/i }).click();\n\n    // Wait for redirect or error\n    await page.waitForTimeout(3000);\n\n    // Should redirect to login or show authentication required\n    const loginOrAuth = page\n      .getByRole('heading', { name: /login/i })\n      .or(page.locator('text=/sign in/i'))\n      .or(page.locator('text=/authentication required/i'));\n\n    await expect(loginOrAuth).toBeVisible({ timeout: 15_000 });\n  });\n\n  test('handles expired token on API request', async ({ page, context }) => {\n    await registerAndLogin(page);\n\n    // Navigate to lobby first\n    await page.getByRole('link', { name: /lobby/i }).click();\n    await page.waitForURL('**/lobby', { timeout: 15_000 });\n\n    // Intercept API to return 401 unauthorized\n    await page.route('**/api/**', (route) => {\n      route.fulfill({\n        status: 401,\n        contentType: 'application/json',\n        body: JSON.stringify({ error: 'Token expired' }),\n      });\n    });\n\n    // Trigger an API call by trying to refresh or navigate\n    await page.reload();\n\n    // Wait for error handling\n    await page.waitForTimeout(3000);\n\n    // Should show login page or auth error\n    const loginOrError = page\n      .getByRole('heading', { name: /login/i })\n      .or(page.locator('.text-red-300, .text-red-400'))\n      .or(page.locator('text=/unauthorized/i'))\n      .or(page.locator('text=/session/i'));\n\n    await expect(loginOrError).toBeVisible({ timeout: 15_000 });\n\n    await page.unroute('**/api/**');\n  });\n});\n\ntest.describe('Error Recovery - Rate Limiting', () => {\n  test.setTimeout(120_000);\n\n  test('handles rate limiting gracefully', async ({ page }) => {\n    const loginPage = new LoginPage(page);\n    await loginPage.goto();\n    await loginPage.waitForReady();\n\n    // Intercept login API and return 429\n    await page.route('**/api/auth/login', (route) => {\n      route.fulfill({\n        status: 429,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          error: 'Too many requests',\n          retryAfter: 60,\n        }),\n        headers: {\n          'Retry-After': '60',\n        },\n      });\n    });\n\n    // Attempt login\n    const user = generateTestUser();\n    await loginPage.login(user.email, user.password);\n\n    // Wait for error state\n    await page.waitForTimeout(2000);\n\n    // Should show rate limit error or general error (page shouldn't crash)\n    const errorOrForm = page\n      .locator('.text-red-300, .text-red-400, [class*=\"error\"]')\n      .or(page.getByRole('heading', { name: /login/i }));\n    await expect(errorOrForm).toBeVisible({ timeout: 10_000 });\n\n    await page.unroute('**/api/auth/login');\n  });\n\n  test('handles rate limiting on game API calls', async ({ page }) => {\n    await registerAndLogin(page);\n\n    // Navigate to lobby\n    await page.getByRole('link', { name: /lobby/i }).click();\n    await page.waitForURL('**/lobby', { timeout: 15_000 });\n\n    // Intercept games API with rate limit\n    await page.route('**/api/games**', (route) => {\n      route.fulfill({\n        status: 429,\n        contentType: 'application/json',\n        body: JSON.stringify({ error: 'Rate limit exceeded. Please try again later.' }),\n      });\n    });\n\n    // Try to create a game\n    await page.getByRole('button', { name: /\\+ Create Game/i }).click();\n    await expect(page.getByRole('heading', { name: /Create Backend Game/i })).toBeVisible({\n      timeout: 5_000,\n    });\n    await page.getByRole('button', { name: /^Create Game$/i }).click();\n\n    // Wait for error handling\n    await page.waitForTimeout(3000);\n\n    // Form should still be visible or error shown\n    const formOrError = page\n      .getByRole('heading', { name: /Create Backend Game/i })\n      .or(page.locator('.text-red-300, .text-red-400'));\n    await expect(formOrError).toBeVisible({ timeout: 10_000 });\n\n    await page.unroute('**/api/games**');\n  });\n});\n\ntest.describe('Error Recovery - Form Validation', () => {\n  test.setTimeout(90_000);\n\n  test('shows validation errors for empty registration form', async ({ page }) => {\n    const registerPage = new RegisterPage(page);\n    await registerPage.goto();\n    await registerPage.waitForReady();\n\n    // Submit empty form\n    await registerPage.clickCreateAccount();\n\n    // Wait for validation\n    await page.waitForTimeout(1000);\n\n    // Should show validation errors or prevent submission\n    // The form should still be visible (not navigated away)\n    await expect(registerPage.heading).toBeVisible();\n  });\n\n  test('shows error for invalid email format during registration', async ({ page }) => {\n    const registerPage = new RegisterPage(page);\n    await registerPage.goto();\n    await registerPage.waitForReady();\n\n    // Fill with invalid email\n    await registerPage.fillEmail('not-a-valid-email');\n    await registerPage.fillUsername('testuser123');\n    await registerPage.fillPassword('ValidPassword123!');\n    await registerPage.fillConfirmPassword('ValidPassword123!');\n    await registerPage.clickCreateAccount();\n\n    // Wait for validation\n    await page.waitForTimeout(2000);\n\n    // Should show validation error or stay on form\n    const formStillVisible = await registerPage.heading.isVisible();\n    expect(formStillVisible).toBeTruthy();\n  });\n\n  test('shows error for password mismatch during registration', async ({ page }) => {\n    const registerPage = new RegisterPage(page);\n    await registerPage.goto();\n    await registerPage.waitForReady();\n\n    const user = generateTestUser();\n    await registerPage.fillEmail(user.email);\n    await registerPage.fillUsername(user.username);\n    await registerPage.fillPassword('Password123!');\n    await registerPage.fillConfirmPassword('DifferentPassword456!');\n    await registerPage.clickCreateAccount();\n\n    // Wait for validation\n    await page.waitForTimeout(2000);\n\n    // Should show error or stay on form\n    const errorOrForm = page\n      .locator('.text-red-300, .text-red-400, [class*=\"error\"]')\n      .or(registerPage.heading);\n    await expect(errorOrForm).toBeVisible({ timeout: 10_000 });\n  });\n\n  test('preserves form state after validation error', async ({ page }) => {\n    const registerPage = new RegisterPage(page);\n    await registerPage.goto();\n    await registerPage.waitForReady();\n\n    const user = generateTestUser();\n    const invalidEmail = 'not-valid-email';\n\n    // Fill form with invalid email\n    await registerPage.fillEmail(invalidEmail);\n    await registerPage.fillUsername(user.username);\n    await registerPage.fillPassword(user.password);\n    await registerPage.fillConfirmPassword(user.password);\n\n    // Submit\n    await registerPage.clickCreateAccount();\n\n    // Wait for validation\n    await page.waitForTimeout(2000);\n\n    // Form should preserve username (email might be cleared based on HTML5 validation)\n    const usernameValue = await page.getByLabel('Username').inputValue();\n    expect(usernameValue).toBe(user.username);\n  });\n\n  test('shows error for short password during registration', async ({ page }) => {\n    const registerPage = new RegisterPage(page);\n    await registerPage.goto();\n    await registerPage.waitForReady();\n\n    const user = generateTestUser();\n    await registerPage.fillEmail(user.email);\n    await registerPage.fillUsername(user.username);\n    await registerPage.fillPassword('short'); // Too short\n    await registerPage.fillConfirmPassword('short');\n    await registerPage.clickCreateAccount();\n\n    // Wait for validation\n    await page.waitForTimeout(2000);\n\n    // Should show error or stay on form\n    const formStillVisible = await registerPage.heading.isVisible();\n    expect(formStillVisible).toBeTruthy();\n  });\n});\n\ntest.describe('Error Recovery - Page Reload', () => {\n  test.setTimeout(120_000);\n\n  test('game state persists after page reload', async ({ page }) => {\n    await registerAndLogin(page);\n    await createGame(page);\n    await waitForGameReady(page);\n\n    const gamePage = new GamePage(page);\n    const gameId = gamePage.getGameId();\n    expect(gameId).toBeTruthy();\n\n    // Reload the page\n    await page.reload();\n\n    // Wait for game to reload\n    await gamePage.waitForReady();\n\n    // Verify we're still on the same game\n    expect(gamePage.getGameId()).toBe(gameId);\n    await expect(gamePage.boardView).toBeVisible();\n  });\n\n  test('handles reload during loading state', async ({ page }) => {\n    await registerAndLogin(page);\n\n    // Start navigating to lobby\n    await page.getByRole('link', { name: /lobby/i }).click();\n\n    // Immediately reload (during potential loading state)\n    await page.reload();\n\n    // Wait for page to stabilize\n    await page.waitForTimeout(3000);\n\n    // Should end up on a valid page (not crashed)\n    const validPage = page\n      .getByRole('heading', { name: /Game Lobby/i })\n      .or(page.getByRole('heading', { name: /Welcome/i }))\n      .or(page.getByRole('heading', { name: /Login/i }));\n\n    await expect(validPage).toBeVisible({ timeout: 15_000 });\n  });\n});",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/armand/Development/RingRift/tests/e2e/ratings.e2e.spec.ts",
    "messages": [
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\s.",
        "line": 158,
        "column": 53,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 158,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [5502, 5503], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [5502, 5502], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { test, expect } from '@playwright/test';\nimport {\n  registerAndLogin,\n  createGame,\n  generateTestUser,\n} from './helpers/test-utils';\nimport { GamePage, HomePage } from './pages';\n\n/**\n * E2E Test Suite: Ratings and Leaderboard\n * ============================================================================\n *\n * This suite tests rating and leaderboard functionality:\n * - Leaderboard page loading and display\n * - Rating display on profile page\n * - Initial rating for new users\n * - Rating updates after games (limited - requires completed games)\n *\n * INFRASTRUCTURE REQUIREMENTS:\n * - PostgreSQL running (for user and rating persistence)\n * - Redis running (for session management)\n * - Dev server running on http://localhost:5173\n *\n * RUN COMMAND: npx playwright test ratings.e2e.spec.ts\n */\n\ntest.describe('Rating and Leaderboard E2E Tests', () => {\n  test.setTimeout(120_000);\n\n  test.describe('Leaderboard Page', () => {\n    test('leaderboard page loads and displays rankings', async ({ page }) => {\n      await registerAndLogin(page);\n\n      // Navigate to leaderboard\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToLeaderboard();\n\n      // Verify leaderboard heading\n      await expect(page.getByRole('heading', { name: /leaderboard/i })).toBeVisible({\n        timeout: 10_000,\n      });\n\n      // Verify table structure exists\n      const table = page.locator('table');\n      await expect(table).toBeVisible({ timeout: 10_000 });\n\n      // Verify column headers\n      await expect(page.locator('th', { hasText: /rank/i })).toBeVisible();\n      await expect(page.locator('th', { hasText: /player/i })).toBeVisible();\n      await expect(page.locator('th', { hasText: /rating/i })).toBeVisible();\n    });\n\n    test('leaderboard shows player statistics', async ({ page }) => {\n      await registerAndLogin(page);\n\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToLeaderboard();\n\n      // Wait for table to load\n      await expect(page.locator('table')).toBeVisible({ timeout: 10_000 });\n\n      // Check for win rate column\n      const winRateHeader = page.locator('th', { hasText: /win\\s*rate/i });\n      await expect(winRateHeader).toBeVisible();\n\n      // Check for games played column\n      const gamesHeader = page.locator('th', { hasText: /games/i });\n      await expect(gamesHeader).toBeVisible();\n    });\n\n    test('leaderboard displays rating values', async ({ page }) => {\n      await registerAndLogin(page);\n\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToLeaderboard();\n\n      // Wait for table to load\n      await expect(page.locator('table')).toBeVisible({ timeout: 10_000 });\n\n      // If there are users with ratings, verify they're displayed as numbers\n      const ratingCells = page.locator('td.font-mono');\n      const count = await ratingCells.count();\n\n      if (count > 0) {\n        // Get first rating cell text and verify it's a number\n        const firstRating = await ratingCells.first().textContent();\n        if (firstRating) {\n          expect(Number(firstRating.trim())).not.toBeNaN();\n        }\n      }\n    });\n  });\n\n  test.describe('Profile Page Ratings', () => {\n    test('profile page displays user rating', async ({ page }) => {\n      const user = await registerAndLogin(page);\n\n      // Navigate to profile\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      // Wait for profile to load\n      await page.waitForURL('**/profile', { timeout: 10_000 });\n\n      // Verify rating is displayed\n      const ratingSection = page.locator('text=/rating/i');\n      await expect(ratingSection.first()).toBeVisible({ timeout: 10_000 });\n\n      // Look for the rating value - should be a number (default is usually 1200 or 1500)\n      const ratingValue = page.locator('.text-emerald-400, [class*=\"rating\"]').filter({\n        hasText: /\\d+/,\n      });\n      await expect(ratingValue.first()).toBeVisible({ timeout: 5_000 });\n    });\n\n    test('new user starts with initial rating', async ({ page }) => {\n      const user = await registerAndLogin(page);\n\n      // Navigate to profile\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      await page.waitForURL('**/profile', { timeout: 10_000 });\n\n      // New users typically start with a default rating (commonly 1200 or 1500)\n      // Look for rating display\n      const ratingDisplay = page.locator('text=/\\\\d{3,4}/');\n      await expect(ratingDisplay.first()).toBeVisible({ timeout: 5_000 });\n\n      // Verify games played is 0 for new user\n      const gamesPlayed = page.locator('text=/games played/i');\n      await expect(gamesPlayed).toBeVisible();\n\n      // The value should be 0\n      const zeroGames = page.locator(':text(\"0\")');\n      await expect(zeroGames.first()).toBeVisible();\n    });\n\n    test('profile shows wins and losses statistics', async ({ page }) => {\n      await registerAndLogin(page);\n\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      await page.waitForURL('**/profile', { timeout: 10_000 });\n\n      // Check for wins statistic\n      const winsSection = page.locator('text=/wins/i');\n      await expect(winsSection.first()).toBeVisible({ timeout: 5_000 });\n\n      // Check for win rate statistic\n      const winRateSection = page.locator('text=/win\\s*rate/i');\n      await expect(winRateSection).toBeVisible();\n    });\n\n    test('profile displays recent games section', async ({ page }) => {\n      await registerAndLogin(page);\n\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      await page.waitForURL('**/profile', { timeout: 10_000 });\n\n      // Look for recent games section\n      const recentGamesHeader = page.getByRole('heading', { name: /recent games/i });\n      await expect(recentGamesHeader).toBeVisible({ timeout: 5_000 });\n\n      // For a new user, should show \"No games played yet\" or similar\n      const noGamesMessage = page.locator('text=/no games|no matches/i');\n      // Either there's a message or game entries - both are valid states\n      const gameEntries = page.locator('[class*=\"game\"]').filter({\n        hasText: /victory|defeat|draw/i,\n      });\n\n      const hasMessage = await noGamesMessage.count() > 0;\n      const hasGames = await gameEntries.count() > 0;\n\n      // One of these should be true\n      expect(hasMessage || hasGames).toBeTruthy();\n    });\n  });\n\n  test.describe('Rating Updates', () => {\n    test.skip('rating updates after completing a game', async ({ page }) => {\n      // Skip: Requires completing a full game to observe rating changes\n      // This is a complex end-to-end scenario\n      \n      await registerAndLogin(page);\n\n      // Navigate to profile and record initial rating\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      await page.waitForURL('**/profile', { timeout: 10_000 });\n\n      // Get initial rating\n      const initialRatingElement = page.locator('.text-emerald-400').first();\n      const initialRatingText = await initialRatingElement.textContent();\n      const initialRating = parseInt(initialRatingText || '1200', 10);\n\n      // Create and complete a game\n      await homePage.goto();\n      await createGame(page, { vsAI: true });\n\n      // ... game completion logic would go here ...\n      // This requires the game to actually end (win/lose/draw)\n\n      // Navigate back to profile\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      // Check if rating changed (it may not change for unrated games)\n      const newRatingElement = page.locator('.text-emerald-400').first();\n      await expect(newRatingElement).toBeVisible();\n    });\n\n    test.skip('rated games affect rating while unrated games do not', async ({ page }) => {\n      // Skip: Requires both rated and unrated game completion to verify\n      // Marking as skip until full game completion flow is testable\n      \n      await registerAndLogin(page);\n\n      const homePage = new HomePage(page);\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      const initialRating = await page.locator('.text-emerald-400').first().textContent();\n\n      // Create an unrated game and complete it\n      // ... unrated game completion ...\n\n      await homePage.goto();\n      await homePage.goToProfile();\n\n      const ratingAfterUnrated = await page.locator('.text-emerald-400').first().textContent();\n\n      // Rating should not change for unrated games\n      expect(ratingAfterUnrated).toBe(initialRating);\n    });\n  });\n});",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/armand/Development/RingRift/tests/unit/MetricsService.shadowComparator.test.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ')' expected.",
        "line": 28,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import client from 'prom-client';\nimport { MetricsService, getMetricsService } from '../../src/server/services/MetricsService';\n\ndescribe('MetricsService orchestrator shadow metrics bridge', () => {\n  beforeEach(() => {\n    MetricsService.resetInstance();\n    client.register.clear();\n  });\n\n  it('exposes shadow comparator gauges in /metrics output', async () => {\n    const metrics = getMetricsService();\n\n    // Force a refresh so gauges are registered and populated at least once\n    metrics.refreshOrchestratorShadowMetrics();\n\n    const output = await metrics.getMetrics();\n\n    expect(output).toContain('ringrift_orchestrator_shadow_comparisons_current');\n    expect(output).toContain('ringrift_orchestrator_shadow_mismatches_current');\n    expect(output).toContain('ringrift_orchestrator_shadow_mismatch_rate');\n    expect(output).toContain('ringrift_orchestrator_shadow_orchestrator_errors_current');\n    expect(output).toContain('ringrift_orchestrator_shadow_orchestrator_error_rate');\n    expect(output).toContain('ringrift_orchestrator_shadow_avg_legacy_latency_ms');\n    expect(output).toContain('ringrift_orchestrator_shadow_avg_orchestrator_latency_ms');\n  });\n}\n\n",
    "usedDeprecatedRules": [
      { "ruleId": "no-extra-semi", "replacedBy": [] },
      { "ruleId": "no-mixed-spaces-and-tabs", "replacedBy": [] }
    ]
  }
]
