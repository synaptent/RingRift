import { BoardType, Position, Move } from '../types/game';
import {
  getMovementDirectionsForBoardType,
  validateCaptureSegmentOnBoard,
  CaptureSegmentBoardView,
} from './core';

export interface CaptureBoardAdapters {
  isValidPosition(pos: Position): boolean;
  isCollapsedSpace(pos: Position): boolean;
  getStackAt(pos: Position):
    | {
        controllingPlayer: number;
        capHeight: number;
        stackHeight: number;
      }
    | undefined;
  getMarkerOwner(pos: Position): number | undefined;
}

/**
 * Enumerate all legal overtaking capture segments for the given player from
 * the specified stack position, using the same ray-walk semantics as the
 * backend RuleEngine / GameEngine.
 */
export function enumerateCaptureMoves(
  boardType: BoardType,
  from: Position,
  playerNumber: number,
  adapters: CaptureBoardAdapters,
  moveNumber: number
): Move[] {
  const results: Move[] = [];
  const directions = getMovementDirectionsForBoardType(boardType);

  // We need the attacker stack to check cap height
  const attacker = adapters.getStackAt(from);
  if (!attacker || attacker.controllingPlayer !== playerNumber) {
    return results;
  }

  for (const dir of directions) {
    let step = 1;
    let targetPos: Position | undefined;

    // 1. Find target
    while (true) {
      const pos: Position = {
        x: from.x + dir.x * step,
        y: from.y + dir.y * step,
        ...(dir.z !== undefined && { z: (from.z || 0) + dir.z * step }),
      };

      if (!adapters.isValidPosition(pos)) {
        break;
      }

      if (adapters.isCollapsedSpace(pos)) {
        break;
      }

      const stack = adapters.getStackAt(pos);
      if (stack && stack.stackHeight > 0) {
        if (attacker.capHeight >= stack.capHeight) {
          targetPos = pos;
        }
        break;
      }

      step++;
    }

    if (!targetPos) continue;

    // 2. Find landing
    let landingStep = 1;
    while (true) {
      const landingPos: Position = {
        x: targetPos.x + dir.x * landingStep,
        y: targetPos.y + dir.y * landingStep,
        ...(dir.z !== undefined && { z: (targetPos.z || 0) + dir.z * landingStep }),
      };

      if (!adapters.isValidPosition(landingPos)) {
        break;
      }

      if (adapters.isCollapsedSpace(landingPos)) {
        break;
      }

      const landingStack = adapters.getStackAt(landingPos);
      if (landingStack && landingStack.stackHeight > 0) {
        break;
      }

      // Validate the full segment
      const view: CaptureSegmentBoardView = {
        isValidPosition: adapters.isValidPosition,
        isCollapsedSpace: adapters.isCollapsedSpace,
        getStackAt: adapters.getStackAt,
        getMarkerOwner: adapters.getMarkerOwner,
      };

      const ok = validateCaptureSegmentOnBoard(
        boardType,
        from,
        targetPos,
        landingPos,
        playerNumber,
        view
      );

      if (ok) {
        results.push({
          id: '', // ID should be generated by caller or left empty for ephemeral checks
          type: 'overtaking_capture', // Or continue_capture_segment, caller can adjust
          player: playerNumber,
          from,
          captureTarget: targetPos,
          to: landingPos,
          timestamp: new Date(),
          thinkTime: 0,
          moveNumber,
        });
      }

      landingStep++;
    }
  }

  return results;
}
