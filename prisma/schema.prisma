// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  passwordHash  String
  role          UserRole  @default(USER)
  rating        Int       @default(1200)
  gamesPlayed   Int       @default(0)
  gamesWon      Int       @default(0)
  emailVerified Boolean   @default(false)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?
  tokenVersion  Int       @default(0)
  deletedAt     DateTime?

  // Auth tokens
  verificationToken        String?
  verificationTokenExpires DateTime?
  passwordResetToken       String?
  passwordResetExpires     DateTime?

  // Game relationships
  gamesAsPlayer1 Game[] @relation("Player1")
  gamesAsPlayer2 Game[] @relation("Player2")
  gamesAsPlayer3 Game[] @relation("Player3")
  gamesAsPlayer4 Game[] @relation("Player4")
  gamesWonGames  Game[] @relation("Winner")
  moves          Move[]
  refreshTokens  RefreshToken[]
  chatMessages   ChatMessage[]
  rematchRequests RematchRequest[] @relation("RematchRequester")
  ratingHistory  RatingHistory[]

  // Index for efficient soft-delete filtering queries
  @@index([deletedAt])
  @@map("users")
}

model Game {
  id              String     @id @default(cuid())
  boardType       BoardType
  maxPlayers      Int
  timeControl     Json // { initialTime: number, increment: number }
  isRated         Boolean    @default(true)
  allowSpectators Boolean    @default(true)
  status          GameStatus @default(waiting)
  gameState       Json       @default("{}")
  rngSeed         Int?       // Per-game RNG seed for deterministic replay

  // Players
  player1Id String?
  player1   User?   @relation("Player1", fields: [player1Id], references: [id])
  player2Id String?
  player2   User?   @relation("Player2", fields: [player2Id], references: [id])
  player3Id String?
  player3   User?   @relation("Player3", fields: [player3Id], references: [id])
  player4Id String?
  player4   User?   @relation("Player4", fields: [player4Id], references: [id])

  // Game result
  winnerId String?
  winner   User?   @relation("Winner", fields: [winnerId], references: [id])

  // Final game state snapshot for completed games
  finalState Json?      // Complete GameState at game end for replay/analysis

  // Game record metadata for training data pipelines
  // Contains: source (online_game, self_play, cmaes_optimization, etc.),
  //           tags[], generation, candidateId, recordVersion
  recordMetadata Json?
  
  // Final score breakdown at game end
  // Contains: ringsEliminated, territorySpaces, ringsRemaining per player
  finalScore    Json?
  
  // Game outcome type
  outcome       String?   // ring_elimination, territory_control, last_player_standing, etc.

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  startedAt DateTime?
  endedAt   DateTime?

  // Related data
  moves           Move[]
  chatMessages    ChatMessage[]
  rematchRequests RematchRequest[]

  @@map("games")
}

model Move {
  id         String   @id @default(cuid())
  gameId     String
  game       Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  playerId   String
  player     User     @relation(fields: [playerId], references: [id])
  moveNumber Int
  position   Json // { from?: Position, to: Position } - legacy position data
  moveType   MoveType
  moveData   Json?    // Rich move data including captured stacks, formed lines, etc.
  timestamp  DateTime @default(now())

  @@unique([gameId, moveNumber])
  @@index([gameId, timestamp])
  @@map("moves")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum BoardType {
  square8
  square19
  hex8
  hexagonal
}

enum GameStatus {
  waiting
  active
  completed
  cancelled
  paused
  abandoned
  finished
}

enum MoveType {
  // Ring placement phase
  place_ring
  skip_placement
  
  // Movement phase
  move_ring        // Legacy alias for move_stack
  move_stack
  build_stack
  
  // Capture moves
  overtaking_capture
  continue_capture_segment
  
  // Line processing decisions
  process_line
  choose_line_reward
  
  // Territory processing decisions
  process_territory_region
  eliminate_rings_from_stack

  // Recovery action (RR-CANON-R110â€“R115)
  recovery_slide

  // Legacy / experimental (kept for backward compatibility)
  line_formation
  territory_claim
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Token family tracking for refresh token rotation and reuse detection.
  // All tokens in the same family share a familyId. When a token is rotated,
  // the new token inherits the same familyId. If a token from an old family
  // is reused, the entire family is revoked (security measure against token theft).
  familyId  String?

  // Marks the token as revoked. Instead of deleting, we mark as revoked to
  // detect reuse attacks: if a revoked token is presented, we know the token
  // chain has been compromised and should revoke the entire family.
  revokedAt DateTime?

  // Whether this token was created with "Remember me" enabled.
  // When true, the token expiry is extended to 30 days instead of 7 days.
  // This flag is preserved during token rotation to maintain the user's preference.
  rememberMe Boolean @default(false)

  @@index([familyId])
  @@map("refresh_tokens")
}

// Chat messages for in-game communication
model ChatMessage {
  id        String   @id @default(cuid())
  gameId    String
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  message   String   @db.VarChar(500) // Max 500 chars per message
  createdAt DateTime @default(now())

  // Index for efficient retrieval of messages by game (ordered by time)
  @@index([gameId, createdAt])
  @@map("chat_messages")
}

// Rematch requests for completed games
model RematchRequest {
  id            String              @id @default(cuid())
  gameId        String
  game          Game                @relation(fields: [gameId], references: [id], onDelete: Cascade)
  requesterId   String
  requester     User                @relation("RematchRequester", fields: [requesterId], references: [id])
  status        RematchRequestStatus @default(pending)
  expiresAt     DateTime            // 30 second timeout
  respondedAt   DateTime?
  newGameId     String?             // ID of the new game if accepted
  createdAt     DateTime            @default(now())

  // Only one pending rematch request per game at a time
  @@unique([gameId, status])
  @@index([gameId, status])
  @@map("rematch_requests")
}

enum RematchRequestStatus {
  pending
  accepted
  declined
  expired
}

// Rating history for tracking player rating changes over time
model RatingHistory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  gameId    String?  // Reference to the game that caused this change (null for initial rating)
  oldRating Int
  newRating Int
  change    Int      // newRating - oldRating
  timestamp DateTime @default(now())

  @@index([userId, timestamp])
  @@index([gameId])
  @@map("rating_history")
}
