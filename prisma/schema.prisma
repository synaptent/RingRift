// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  passwordHash  String
  role          UserRole  @default(USER)
  rating        Int       @default(1200)
  gamesPlayed   Int       @default(0)
  gamesWon      Int       @default(0)
  emailVerified Boolean   @default(false)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?
  tokenVersion  Int       @default(0)
  deletedAt     DateTime?

  // Auth tokens
  verificationToken        String?
  verificationTokenExpires DateTime?
  passwordResetToken       String?
  passwordResetExpires     DateTime?

  // Game relationships
  gamesAsPlayer1 Game[] @relation("Player1")
  gamesAsPlayer2 Game[] @relation("Player2")
  gamesAsPlayer3 Game[] @relation("Player3")
  gamesAsPlayer4 Game[] @relation("Player4")
  gamesWonGames  Game[] @relation("Winner")
  moves          Move[]
  refreshTokens  RefreshToken[]
  chatMessages   ChatMessage[]
  rematchRequests RematchRequest[] @relation("RematchRequester")
  ratingHistory  RatingHistory[]
  matchmakingQueue MatchmakingQueue[]

  // Index for efficient soft-delete filtering queries
  @@index([deletedAt])
  @@map("users")
}

model Game {
  id              String     @id @default(cuid())
  inviteCode      String?    @unique
  boardType       BoardType
  maxPlayers      Int
  timeControl     Json // { initialTime: number, increment: number }
  isRated         Boolean    @default(true)
  allowSpectators Boolean    @default(true)
  status          GameStatus @default(waiting)
  gameState       Json       @default("{}")
  rngSeed         Int?       // Per-game RNG seed for deterministic replay

  // Players
  player1Id String?
  player1   User?   @relation("Player1", fields: [player1Id], references: [id])
  player2Id String?
  player2   User?   @relation("Player2", fields: [player2Id], references: [id])
  player3Id String?
  player3   User?   @relation("Player3", fields: [player3Id], references: [id])
  player4Id String?
  player4   User?   @relation("Player4", fields: [player4Id], references: [id])

  // Game result
  winnerId String?
  winner   User?   @relation("Winner", fields: [winnerId], references: [id])

  // Final game state snapshot for completed games
  finalState Json?      // Complete GameState at game end for replay/analysis

  // Game record metadata for training data pipelines
  // Contains: source (online_game, self_play, cmaes_optimization, etc.),
  //           tags[], generation, candidateId, recordVersion
  recordMetadata Json?
  
  // Final score breakdown at game end
  // Contains: ringsEliminated, territorySpaces, ringsRemaining per player
  finalScore    Json?
  
  // Game outcome type
  outcome       String?   // ring_elimination, territory_control, last_player_standing, etc.

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  startedAt DateTime?
  endedAt   DateTime?

  // Related data
  moves           Move[]
  chatMessages    ChatMessage[]
  rematchRequests RematchRequest[]

  // Indexes for efficient querying of game lists
  @@index([status])
  @@index([createdAt])
  @@index([status, createdAt])
  // Player lookups (getUserGames OR filter on player1Id..player4Id)
  @@index([player1Id])
  @@index([player2Id])
  @@index([player3Id])
  @@index([player4Id])
  @@map("games")
}

model Move {
  id         String   @id @default(cuid())
  gameId     String
  game       Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  playerId   String
  player     User     @relation(fields: [playerId], references: [id])
  moveNumber Int
  position   Json // { from?: Position, to: Position } - legacy position data
  moveType   MoveType
  moveData   Json?    // Rich move data including captured stacks, formed lines, etc.
  timestamp  DateTime @default(now())

  @@unique([gameId, moveNumber])
  @@index([gameId, timestamp])
  @@map("moves")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum BoardType {
  square8
  square19
  hex8
  hexagonal
}

enum GameStatus {
  waiting
  active
  completed
  cancelled
  paused
  abandoned
  finished
}

enum MoveType {
  // Ring placement phase
  place_ring
  skip_placement
  no_placement_action    // Forced no-op when no legal placement (RR-CANON-R075)

  // Movement phase
  move_ring              // Legacy alias for move_stack
  move_stack
  build_stack
  no_movement_action     // Forced no-op when no legal movement (RR-CANON-R075)
  skip_capture           // Decline optional capture after movement (RR-CANON-R070)

  // Capture moves
  overtaking_capture
  continue_capture_segment

  // Line processing decisions
  process_line
  choose_line_reward     // Legacy alias
  choose_line_option     // Canonical name for line reward decision
  no_line_action         // Forced no-op when no lines to process (RR-CANON-R075)

  // Territory processing decisions
  process_territory_region
  choose_territory_option
  skip_territory_processing  // Voluntary skip of territory processing
  no_territory_action        // Forced no-op when no regions to process (RR-CANON-R075)
  eliminate_rings_from_stack

  // Recovery action (RR-CANON-R110â€“R115)
  recovery_slide
  skip_recovery          // Decline recovery this turn (RR-CANON-R115)

  // Forced elimination (RR-CANON-R100, RR-CANON-R204)
  forced_elimination

  // Game meta-moves
  swap_sides             // Pie rule / swap colours in 2-player games
  resign                 // Player forfeits
  timeout                // Player ran out of time

  // Legacy / experimental (kept for backward compatibility)
  line_formation
  territory_claim
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Token family tracking for refresh token rotation and reuse detection.
  // All tokens in the same family share a familyId. When a token is rotated,
  // the new token inherits the same familyId. If a token from an old family
  // is reused, the entire family is revoked (security measure against token theft).
  familyId  String?

  // Marks the token as revoked. Instead of deleting, we mark as revoked to
  // detect reuse attacks: if a revoked token is presented, we know the token
  // chain has been compromised and should revoke the entire family.
  revokedAt DateTime?

  // Whether this token was created with "Remember me" enabled.
  // When true, the token expiry is extended to 30 days instead of 7 days.
  // This flag is preserved during token rotation to maintain the user's preference.
  rememberMe Boolean @default(false)

  @@index([familyId])
  @@map("refresh_tokens")
}

// Chat messages for in-game communication
model ChatMessage {
  id        String   @id @default(cuid())
  gameId    String
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  message   String   @db.VarChar(500) // Max 500 chars per message
  createdAt DateTime @default(now())

  // Index for efficient retrieval of messages by game (ordered by time)
  @@index([gameId, createdAt])
  @@map("chat_messages")
}

// Rematch requests for completed games
model RematchRequest {
  id            String              @id @default(cuid())
  gameId        String
  game          Game                @relation(fields: [gameId], references: [id], onDelete: Cascade)
  requesterId   String
  requester     User                @relation("RematchRequester", fields: [requesterId], references: [id])
  status        RematchRequestStatus @default(pending)
  expiresAt     DateTime            // 30 second timeout
  respondedAt   DateTime?
  newGameId     String?             // ID of the new game if accepted
  createdAt     DateTime            @default(now())

  // Only one pending rematch request per game at a time
  @@unique([gameId, status])
  @@index([gameId, status])
  @@map("rematch_requests")
}

enum RematchRequestStatus {
  pending
  accepted
  declined
  expired
}

// Rating history for tracking player rating changes over time
model RatingHistory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  gameId    String?  // Reference to the game that caused this change (null for initial rating)
  oldRating Int
  newRating Int
  change    Int      // newRating - oldRating
  timestamp DateTime @default(now())

  @@index([userId, timestamp])
  @@index([gameId])
  @@map("rating_history")
}

// Matchmaking queue entries - persists queue state across restarts
model MatchmakingQueue {
  id              String              @id @default(cuid())
  ticketId        String              @unique  // External reference ID
  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Preferences
  boardType       BoardType
  ratingRangeMin  Int
  ratingRangeMax  Int
  timeControlMin  Int                 // Seconds
  timeControlMax  Int                 // Seconds

  // State
  status          MatchmakingQueueStatus @default(searching)
  rating          Int                 // Snapshot of rating when joined
  joinedAt        DateTime            @default(now())
  matchedAt       DateTime?
  cancelledAt     DateTime?
  gameId          String?             // Game created when matched
  matchedWithId   String?             // The other player's queue entry ID

  // Server tracking (for multi-instance support)
  serverId        String?             // Which server instance owns this entry
  lastHeartbeat   DateTime            @default(now())

  @@unique([userId, status])  // Only one active queue entry per user
  @@index([status, boardType])
  @@index([status, rating])
  @@index([joinedAt])
  @@map("matchmaking_queue")
}

enum MatchmakingQueueStatus {
  searching      // Actively looking for match
  matching       // Found potential match, creating game
  matched        // Successfully matched and game created
  cancelled      // User cancelled or disconnected
  expired        // Timed out waiting for match
}

// Matchmaking analytics and metrics
model MatchmakingMetrics {
  id              String    @id @default(cuid())
  ticketId        String    // Reference to queue entry
  userId          String
  boardType       BoardType
  rating          Int

  // Timing metrics
  joinedAt        DateTime
  matchedAt       DateTime?
  waitTimeMs      Int?      // Time in queue until match (null if cancelled/expired)

  // Match quality
  ratingDiff      Int?      // Rating difference with matched opponent
  matchQualityScore Float?  // 0-1 score based on various factors

  // Outcome
  outcome         MatchmakingOutcome

  // Context
  queueSizeAtJoin Int?      // How many were in queue when joined
  queueSizeAtMatch Int?     // How many were in queue when matched

  createdAt       DateTime  @default(now())

  @@index([userId, createdAt])
  @@index([boardType, createdAt])
  @@index([outcome, createdAt])
  @@map("matchmaking_metrics")
}

enum MatchmakingOutcome {
  matched           // Successfully found a match
  cancelled_user    // User cancelled
  cancelled_disconnect  // User disconnected
  expired           // Timed out
}
